<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[进程和线程详解]]></title>
      <url>%2F2017%2F05%2F27%2Fthread%2F</url>
      <content type="text"><![CDATA[1.进程和线程的理解 (1) 概念背景CPU与其他PC资源之间速度的不协调，人们想提高资源利用率，所以人们提出了多任务系统。得益于CPU的计算速度，我们可以“同时”运行多个任务，实质上是多个任务之间轮流使用CPU资源，由于速度超快，给用户的感觉就是连续的。 首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述 下面细说背景： CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。 一个最最基础的事实： CPU太快，太快，太快了！ 寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。 一个必须知道的事实： 执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。 串联起来的事实： 前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。 ===========================总结起来============================ 进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文 线程是什么呢？ 进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成： 程序A得到CPU -&gt; CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。 这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。 以上来自知乎大神总结，感觉很清晰。 链接：https://www.zhihu.com/question/25532384/answer/81152571 (2) 概念定义 进程：一个具有独立功能的程序关于某个数据集合的以此运行活动。是系统进行资源分配和调度的独立单位，也是基本的执行单元。是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动。 线程：线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（程序计数器，一组寄存器和栈），但它可与同属一个进程的其他线程共享进程所拥有的全部资源。 线程优点： （1）易于调度。 （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一个程序的不同部分。 （3）开销少。创建线程比创建进程要快，所需开销少，占用的资源也少； （4）充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，是每个处理器都得到充分的运行。 总结起来： （1）进程作为分配资源的基本单位(地址空间，全局变量，文件描述符，信号量等)； （2）线程作为独立运行和独立调度的基本单位； 2.进程的状态和具体情况因为CPU执行的速度非常块，所以进程吧所有的资源都准备好才可以执行，无需CPU再等待。 （1）就绪（Ready）状态： 当进程分配到除CPU以外的必要资源后，只要再获得CPU，便可以立即执行，进程这时的状态为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 （2）阻塞(Blocked)状态： 正在执行的进程由于发生某事件或接受某消息无法继续执行时，便放弃处理机而处于暂停状态，也即进程的执行收到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态和封锁状态。通常使进程处于阻塞的原因有：请求I/O，申请缓冲空间。也会产生一个相应的阻塞队列。 （3）运行（Running）状态： 进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态，在多处理机系统中，则有多个进程处于执行状态； 3.进程和线程的区别（1）调度： 线程作为处理器调度和分配的基本单位，而进程是作为拥有资源的基本单位 （2）并发性： 不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 （3）拥有资源： 进程是拥有资源的一个独立单位，有自己独立的地址空间；线程不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间. （4）系统开销： 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。 4.进程和线程的关系（1）二者均可并发执行. （2）线程是指进程内的一个执行单元,也是进程内的可调度实体。一个程序至少有一个进程,一个进程至少有一个线程，一个线程只属于一个进程. （3）资源分配给进程，同一一进程的所有线程共享该进程的所有资源。 （4）处理机分给线程，即真正在处理机上运行的是线程。 （5）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 5.进程间的关系在多道程序设计系统中，同一时刻可能有许多进程，这些进程之间存在两种基本关系：竞争关系 和 协作关系 进程的互斥、同步、通信都是基于这两种基本关系而存在的： 为了解决进程间竞争关系（间接制约关系）而引入进程互斥； 为了解决进程间松散的协作关系(直接制约关系)而引入进程同步； 为了解决进程间紧密的协作关系而引入进程通信； (1) 进程互斥系统中的多个进程之间彼此无关，它们并不知道其他进程的存在，并且也不受其他进程执行的影响由于这些进程共用了一套计算机系统资源，因而， 必然要出现多个进程竞争资源的问题。当多个进程竞争共享硬设备、存储器、处理器 和文件等资源时，操作系统必须协调好进程对资源的争用。 资源竞争出现了两个控制问题： 一个是死锁 （deadlock ）问题，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁; 一个是饥饿（starvation ）问题，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延; 操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题。 进程的互斥（mutual exclusion ）是解决进程间竞争关系( 间接制约关系) 的手段。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。 实现互斥的基本方法： 硬件实现方法 通过硬件实现临界区最简单的办法就是关CPU的中断。从计算机原理我们知道，CPU进行进程切换是需要通过中断来进行。如果屏蔽了中断那么就可以保证当前进程顺利的将临界区代码执行完，从而实现了互斥。这个办法的步骤就是:屏蔽中断–执行临界区–开中断； 信号量实现方式 这也是我们比较熟悉PV操作。通过设置一个表示资源个数的信号量S，通过对信号量S的P和V操作来实现进程的的互斥；P和V操作分别来自荷兰语Passeren和Vrijgeven，分别表示占有和释放。P V操作是操作系统的原语，意味着具有原子性； P操作首先减少信号量，表示有一个进程将占用或等待资源，然后检测S是否小于0,如果小于0则阻塞，如果大于0则占有资源进行执行。 V操作是和P操作相反的操作，首先增加信号量，表示占用或等待资源的进程减少了1个。然后检测S是否小于0，如果小于0则唤醒等待使用S资源的其它进程。 (2) 进程同步某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行。这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步； 进程间的协作可以是双方不知道对方名字的间接协作，例如，通过共享访问一个缓冲区进行松散式协作；也可以是双方知道对方名字，直接通过通信机制进行紧密协作。允许进程协同工作有利于共享信息、有利于加快计算速度、有利于实现模块化程序设计。 进程的同步（Synchronization）是解决进程间协作关系(直接制约关系)的手段。进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。 不难看出，进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。 进程间的同步方式： Linux下常见的进程同步方法有： (1) SysVIPC 的 sem（信号量）,就是 信号量; (2) file locking / record locking（通过 fcntl 设定的文件锁、记录锁）; (3) futex（基于共享内存的快速用户态互斥锁） 就是 互斥 ; (4) 管程 ; 在Windwos中，进程同步主要有以下几种： (1) 互斥量; (2) 信号量; (3) 事件; (4) 可等计时器; 我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信; 信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。注意，信号量的值仅能由PV操作来改变。 (3)进程间通信(IPC)进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，通过修改信号量，进程之间可建立起联系，相互协调运行和协同工作。但是信号量与PV操作只能传递信号，没有传递数据的能力。有些情况下进程之间交换的信息量虽很少，例如，仅仅交换某个状态信息，但很多情况下进程之间需要交换大批数据，例如，传送一批信息或整个文件，这可以通过一种新的通信机制来完成，进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换) （1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 （2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。 （3）消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。 （4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 （5）信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。 （6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛 几种通信方式的比较1.管道：速度慢，容量有限，只有父子进程能通讯 2.FIFO：任何进程间都能通讯，但速度慢 3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 ，不适宜于信息量大或操作频繁的场合； 4.信号量：不能传递复杂消息，只能用来同步 5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存； 6.线程间的关系（1）线程间同步（4种） 临界区（CCriticalSection） 当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止； 1、 定义临界区对象CcriticalSection g_CriticalSection; 2、 在访问共享资源（代码或变量）之前，先获得临界区对象，g_CriticalSection.Lock（）； 3、 访问共享资源后，则放弃临界区对象，g_CriticalSection.Unlock（）； 事件（CEvent） 事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。每个Cevent对象可以有两种状态：有信号状态和无信号状态。Cevent类对象有两种类型：人工事件和自动事件； 自动事件对象，在被至少一个线程释放后自动返回到无信号状态； 人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创建Cevent对象时，默认创建的是自动事件。 互斥量（CMutex） 互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。 信号量（CSemphore） 当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。 线程间通信 全局变量 主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate 消息机制 在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage 1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20; 2)添加消息函数声明afx_msg int OnTSendmsg(); 3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM) 4)添加OnTSM()的实现函数； 5)在线程函数中添加PostMessage消息Post函数 事件CEvent类 Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作 1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态； 2)threadStart.SetEvent();使其处于通信状态； 3)调用WaitForSingleObject()来监视CEvent对象； 7.多进程和多线程的应用（1）多线程的应用场景多线程的主要是需要处理大量的IO操作或者处理的情况需要花大量的时间等等，比如读写文件，网络数据接收，视频图像的采集，处理显示保存等操作缓慢的情形和需大幅度的提高性能的程序中使用 （2）多线程的缺点线程之间的同步和加锁控制比较麻烦； 一个线程的崩溃可能影响到整个程序的稳定性； 到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数； 线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU （3）多进程的缺点逻辑控制复杂，需要和主程序交互； 需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算 多进程调度开销比较大； 最好是多进程和多线程结合，即根据实际的需要，每个CPU开启一个子进程，这个子进程开启多线程可以为若干同类型的数据进行处理。当然你也可以利用多线程+多CPU+轮询方式来解决问题…… 8.多线程和多进程的区别多线程和多进程的区别。 平常指的多进程是操作系统下同时运行多个进程，比如Word和Excel同时打开，并且可以并行地同时执行一些操作。这种多进程和多线程没什么好比较的。可以比较的是同一个程序里的多线程和多进程。 多线程因为在同一个进程里，所以可以共享内存和其他资源，比如迅雷里10个线程一齐下载一个文件，这个文件是由进程打开的，然后10个线程都可以往里写入东西。如果是10个进程就不行了，操作系统不允许一个文件由两个进程同时写入。另外，Chrome就是一个典型的多进程程序，里面每个标签页、扩展、插件都是单独的进程，各自独占资源，相互隔离，一个进程出错死掉只会影响一个页面或者插件，再也不会出现Flash插件出错崩溃导致整个浏览器崩溃的情况了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hadoop作业提交与初始化过程]]></title>
      <url>%2F2017%2F05%2F25%2Fhadoop-1%2F</url>
      <content type="text"><![CDATA[1.整体流程 如上图，提交job包括前三个阶段，初始化过程是最后一个阶段 2.详解作业提交的过程(1)shell命令提交作业通过Java API，Hadoop Streaming 和Hadoop Pipes方式提交作业，会根据配置将在main函数中调用JobClient.runJob函数提交作业 (2)JobClient根据JobConf上传文件到HDFSJobClient将作业提交到JobTracker上之前，需要获取作业ID，创建HDFS目录，上传作业文件，生成Split文件，这些有JobClient类中的submitJobInternal(job)函数实现，其中的上传文件利用了DistributeCache工具完成。 这其中包括产生InputSplit(输入分片)，用户提交MR后，JobClient会调用InputFormat的getSplits方法生成InputSplit相关信息。其中信息包括两部分：InputSplit元数据信息和原始InputSplit信息其中，InputSplit元数据信息被JobTracker使用；第二部分被Map Task初始化使用，来获取要处理的数据。这两部分信息存储到相关目录下的文件job.splitmetainfo和job.split中。 (3)JobClient调用RPC提交作业到JobTracker提交JobTracker端会进行一下操作： 为作业创建JobInProgress对象 检查用户是否具有指定队列的作业提交权限 检查作业配置的内存使用量是否合理 通知TaskScheduler初始化作业 3.作业初始化过程详解调度器用JobTracker.initJob()函数对新作业进行初始化。作业的初始化的主要工作是构造Map Task 和 Reduce Task 并对他们初始化。initJob会分为以下4个任务：Setup Task，Map Task， Reduce Task , Cleanup Task 参考《Hadoop 技术内幕》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入浅出RPC]]></title>
      <url>%2F2017%2F05%2F23%2FRPC%2F</url>
      <content type="text"><![CDATA[RPC是什么最近在看hadoop的一些东西，看到hadoop rpc时想深入了解一下rpc的东西，于是通过查看资料总结一下； 首先RPC是什么早期的单机时代，一台电脑上运行多个进程，进程在各自的栈帧中运行，进程之间互不交流。假如A进程需要一个获取磁盘数据的功能，B进程也需要一个同样的功能，程序员就必须为两个进程都写一个获取数据的功能。这样很麻烦，于是就出现了IPC（Inter-process communication，单机中运行的进程之间的相互通信）。OK，现在A既然有了获取数据的功能，B就调用A进程上的功能好了，程序员终于可以偷下懒了。 到了网络时代，大家的电脑都连起来了。以前程序只能调用自己电脑上的进程，能不能调用其他机器上的进程呢？于是程序员就把IPC扩展到网络上，这就是RPC（远程过程调用）了。现在不仅单机上的进程可以相互通信，多机器中的进程也可以相互通信了。 其实，RPC就是远程过程调用，两台服务器之间，服务器A要调用服务器B上的方法或函数，由于想要的函数不在同一个机器，内存空间之内，只能通过网络来表达语义和传输数据。 总结起来：简单的说，RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法） 分布式RPC需要解决的问题protocol：传输协议proxy：client代理，服务引用方调用方法通过代理发送远程消息codec：协议编解码压缩等transport：协议传输registry：注册中心，服务注册服务发现cluster：负载均衡，服务容错策略其他：服务降级，服务隔离，服务治理 服务器集群为什么节点间通信为什么要用到RPC (1)当业务较少时，我们有两台机器，服A作为对外服务接口，服B作为内部业务处理，所以对服A的任何请求，直接请求服B就可以了，如图一。(2)随着业务增加，又多了一台内部业务机器，服C，这时只需要对服A进行简单的配置，哪些类访问服B，哪些类访问服C，如图二。(3)然后业务量爆发增长，服A，B，C，D负责处理对外业务，服E，F，G，H 处理对内逻辑，按照上边的逻辑，每当部署一个新业务，都要修改对外服务的几台机器的配置文件，这样显得非常麻烦，并且随着业务量的继续增加，也显得很不现实，如图三 (4) 于是出现了图4所示的架构，服M专门作为服务治理，通过hash方法针对对外的服务进行寻找内部处理机器，这样得到结构再反方向找到对外机器即可，并且所有的对外机器都和服M连接，所以修改起来也非常简单。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我们都是大城市的乞讨者]]></title>
      <url>%2F2017%2F05%2F18%2Fthinking-1%2F</url>
      <content type="text"><![CDATA[—纪念自己实习的那些日子 当年上学时不知道什么是北漂直到自己做了这样一个熟悉又陌生的群体中的一员才深有感觉 来北京实习已经整整一年了去年的5月18号是个特别的日子来到北京入职的第一天住到自己租的房子的第一天认识很重要的一个人的第一天一年来实习了两家优秀的公司认识了不少圈里的朋友也看到了白天的摩天大楼和夜晚的三轮，地摊 北京，是不是充满了梦想我不了解在这里不能比学历总有比你更高的学历不能比财富总有比你挣得更多，更轻松的只能比勤奋因为我们每个人心里都有只要坚持，努力我们会活出我们想成为的样子可是，是这样吗？ 我们都是大城市的乞讨者怀揣着微不足道的信心在这个浮躁的时代能保持初心，善心，耐心，真的很重要还能怎样，一步步走下去吧欣赏着人和事……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[讲不出再见]]></title>
      <url>%2F2017%2F04%2F27%2Ftravel-2%2F</url>
      <content type="text"><![CDATA[回国也有几天了，疲倦还未消散，在巴厘岛的一幕幕也很难在头脑中散去晚上闭上窗帘，拉开心里的序幕总希望快乐环绕，但……我们管过去的叫做最美好的时光我想，当某天无端想起某些人，某些事一定会出现在明天里因为我讲不出再见！ 那天是清晨，没睡，心情依然快乐 巴厘岛的海滩还不错没有一点污染让人心里自然感觉纯净，豁然开朗 巴厘岛的水底真的很清澈人类还是征服不了自然 当地的大餐，我却不怎么喜欢不过还是有点诱人的吧 行程紧密，但很充实感谢团队中的每一个人，带给我快乐和帮助 希望我们的友谊长存希望无论天涯何处，莫要相忘 当然总要走真的一米之遥，或许两岸相隔生活还要继续望各自珍重望……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[孔孟之乡]]></title>
      <url>%2F2017%2F04%2F04%2Ftravel-1%2F</url>
      <content type="text"><![CDATA[“清明时节雨纷纷”，又一个清明节到了，在南方读了大学和研究生，仿佛忘了家里的春天是什么样子，4月的北京雾霾少了，天真的晴朗起来确实还是很美的。趁着清明节的小假期，加上请的两天假，和同学选了个时间比较充裕的地方玩一下—–山东（济南和泰安）。 第一天坐上清晨的高铁去的第一站—-济南。泉城济南，这个城市在我的印象中还停留在初中课本中的文章《济南的冬天》，老舍先生把济南的冬天描述的萧瑟，冷峻。之前从来没去过山东，但印象中的山东人纯朴，老实，毕竟都是孔孟的后代。确实去过之后感觉山东人还是很好的。第一天去了趵突泉，由于是节日人还是挺多的。但是趵突泉没有给我很大的惊喜，或许是时间还没到吧，泉水喷的并不是很冲，但是也能感觉到春天的脚步近了，到处都生机盎然…… 第二天去济南我们都知道要看三大景观，趵突泉，千佛山，大明湖。第二天我们的目的地就是后两者。因为住的宾馆离大明湖比较近，就进去了大明湖。抱着看看”大明湖畔的夏紫薇”,但是始终没有找到，仅仅是围绕着湖的岸边装了一圈，感觉大明湖就是一个人们休闲的大公园，也是这三个景点唯一不需要门票的地方，春天来了还是不错的。 下午去了千佛山，其实赶巧了，正好遇到三月三千佛山庙会，人确实很多；千佛山，顾名思义，山上基本都是佛，但山确实并不高，大概200多米，我们也只是简单爬了下，看了眼济南的全城，感觉济南的雾霾太大了。 在济南呆了两天吧，总体感觉济南这个城市基础建设一般，司机师傅说正在建地铁，但是城市感觉有点乱，街道并不是很干净，但是消费相对较低，人们还是很和蔼的。玩了三个地方，品尝下济南的小吃街，算是不虚此行…… 第三天第三天是重点—-泰山。我们并没有打算去看泰山的日出，最主要的原因是太累，基本上晚上10点前要开始爬山，凌晨3点左右到山顶，觉得这样太累。于是决定就白天上山，体会一下一览众山小的感觉就好了。这样，早上8点多到泰安，做公交直达泰山山脚下开始行程。我们还特意记录了时间，从10：00开始爬；爬泰山分两部分，一是前半部分山脚到中天门，也是比较好爬的一段路程。比较平坦；后半部分从中天门到南天门再到玉皇顶，相对难很多了。尤其是十八盘那段，很陡的山路，基本上都要休息下。其实越是休息越累，这个就是一鼓作气，也是在后半部分泰山的人文景观就开始多了。包括各种名人提的字等，上山时其实不用带干粮，山上的吃的并不贵，这点我们之前没有想到，背着几瓶水登山也是……； 五岳之首，泰山1500多米，确实有种霸气的感觉；泰山以其独特的文化气息在中国山脉届占有重要的地位。当经过疲惫的攀登，到达玉皇顶的那一刻还是感觉异常的兴奋，真的有众山小的感觉。 结束三天的旅行，虽然累，但是心情却是满足的； 其实人生就像一场旅行，在乎的不是目的地，在乎的是沿途的风景以及看风景的心情…… 生活依然前行，旅行还在继续，下一个……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(4)]]></title>
      <url>%2F2017%2F03%2F08%2FEffective-C-4%2F</url>
      <content type="text"><![CDATA[四.设计与声明 18.条款18:让接口容易被正确使用，不易被误用 记住以下几点即可：1.好的接口很容易被正确使用，不容易被误用，我们需要在我们的所有接口中努力达成这些性质；2.正确使用接口的办法包括接口的一致性，以及与内置类型的行为兼容；3.防止误用的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。4.tr1::shared_ptr支持定制型删除器。这可防止DLL问题，可被用来自动解除互斥锁等等； 19.条款19:设计class犹如设计type这个条款需要记住，当定义一个新的class，也就定义了一个新的type。这就意味着我们重载函数和操作符，控制内存的分配和归还，定义对象的初始化和终结……都掌握在我们自己的手上。 m m所以设计一个优秀的class是一项艰巨的任务。 20.条款20:宁以pass-by-reference-to-const替换pass-by-value这个条款很重要 缺省情况下C++以by value方式传递对象到函数，这样函数参数都是以实际参数的副本为初值，这些副本也是由对象的copy构造函数产出，这就使得pass-by-value成为昂贵的操作； 基于此，有两点好处需要详解例一： class Person { public: Person(); virtual ~Person(); ... private: std::string name; std::string address; }; class Student:public Person { public: Student(); ~Student(); ... private: std::string schoolName; std::string schoolAddress; }; 考虑这样的情况，调用函数validateStudent，这个函数需要一个Student的参数（by value）， bool validateStudent （Student s）; //函数接受一个by value的参数 Student plato； bool platoIsOK = validateStudent(plato); //调用函数 看一下吧。无疑，Student的copy构造函数会被调用，加上validataStudent返回s会被销毁，因此参数传递的成本是一次copy函数调用，一次Student析构函数调用； 这只是简单的一点，当我们深入去研究会发现，Student有两个string对象，所以每次构造Student同时也构造了两个string对象，同时Student对象继承字Person，Person中也有两个string对象，也需要构造两个string对象，最终结果是以by value传递参数会有一次Student copy构造函数，一次Person copy构造函数，4次string copy 构造函数，当销毁时伴随着6次析构的过程。所以一共是6次copy构造，6次析构； 这样为避免如此多的消耗，我们需要用pass by reference-to-const这种传递方式效率要高很多：没有任何构造函数和析构函数被调用，因为没有任何新对象呗创建，但是这里的const是必要的，原来的by value 传递的是副本，无论怎么修改源对象时不变的，这里却不同了，所以加上const是必要的。 例二：以by reference 方式传递参数可以避免slicing(对象切割)问题。就是说，当一个继承类对象以by value的方式传递并被视作一个基类对象，基类的copy 构造函数会被调用，从而造成本来是针对继承类的对象的性质全被切割掉了，仅仅留下了一个基类对象。 class Windows { public: ... std::string name() const; virtual void display() const; //实现方式1 }; class WindowsWithScrollBars:public Windows { public: ... virtual void display() const; //实现方式2 }; 现在我们需要打印窗口名称和显示窗口，这个是错误的 void printNameAndDisplay(Windows w){ std::cout &lt;&lt;w.name(); w.display(); } 当我们传递给函数一个WindowWithScrollBars对象 WindowEithScrollBars wwsb; printNameAndDisplay(wwsb); 参数w会百构造成一个Windows对象，因为这个是pass by value，这个WindowEithScrollBars对象的特有的信息会被切除；在printNameAndDisplay中无论传进来的对象原本是是什么类型，参数w都会被强制转化成Window对象，因此函数中调用display(),永远是调用Window::display(); 解决这个问题的方式就是 by reference-to-const 这样参数不会被切割，传进来什么类型就表现什么类型； 当我们审视C++编译器的底层，会发现references往往是以指针实现出来的，因此pass by reference通常意味着传递指针。但当对象时内置类型时，pass by value 却比 pass by reference效率更高，同时这个tip也适用于STL的迭代器和函数对象，习惯上这些都被设计成pass by value 总结 1.尽量以pass-by-reference-to-const 替换pass-by-value前者通常比较高效，并可避免切割问题；2.但针对内置类型，STL的迭代器和函数对象，pass-by-value更加高效； 21.条款21:必须返回对象时，别妄想返回其reference任何时候看到一个reference声明式，你都应该立刻问自己，它的另一个名称是什么，因为它一定是某物的另一个名称。例如operator*为例，如果它返回一个reference，后者一定指向某个既有的对象，内含两个对象的乘积； 总结下来就是： 绝对不要返回pointer或者reference指向一个local stack 对象，或返回reference指向一个heap-allocated对象，或者返回pointer或reference指向一个local static 对象而有可能同时需要多个这样的对象 22.条款22:将成员变量声明为private总结起来： 1.一定要将成员变量声明为private,这样能赋予客户访问数据的一致性，允许约束条件获得保障，并提供class作者以充分的实现弹性； 2.protected并不比public更具封装性； 23.条款23:宁以non-menber，non-friend替换menber函数要以non-member， non-freend函数替换member函数，这样做可以增加封装性，包裹弹性，和机能扩充性； 24.条款24:若所有参数皆需要类型转换，请为此采用non-menber函数如果需要为某个函数的所有参数进行类型转换，那么这个函数必须是个non-member函数，尤其是针对操作符重载 25.条款25:考虑写出一个不抛出异常的swap函数总结1.当std::swap 对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常；2.如果你提供一个member swap ,也该提供一个non-member swap 用来调用前者。对于classes(而非templates),也请特化std::swap;3.调用swap时应对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”；4.为“用户定义类型”进行谁提的templates全特化是好的，但不要在std内加入某些对std而言全新的东西]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(3)]]></title>
      <url>%2F2017%2F03%2F06%2FEffective-C-3%2F</url>
      <content type="text"><![CDATA[三.资源管理 13.条款13:以对象管理资源在C++中，动态分配的内存是需要我们手动去释放掉的，否则就会造成内存泄漏。把资源放进对象内，我们便可以依赖C++的“析构函数”自动调用机制，确保资源被释放。 于是有两个关键的想法：1.获得资源后立刻放进管理对象 资源取得时机就是初始化时机（RAII）2.管理对象运用析构函数确保资源被释放标准库中提供的智能指针，auto_ptr,tr1::shared_ptrs就是在其析构函数内做delete，但不是delete[]，故在动态分配得到的array中使用这两者并不适用 总结1.为防止资源泄露，应使用RAII对象，他们在构造函数中获得资源并在析构函数中释放资源；2.两个常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向NULL。 14.条款14:在资源管理类中小心copy行为这个情况是面对当一个RAII对象被复制时，会发生什么？多数情况会有以下几种可能：1.禁止复制；将copying操作声明为private。2.对底层资源应用“引用计数法”，例如：tr1::shared_ptr3.复制底部资源；复制底部资源管理对象时，进行的是深拷贝4.转移底部资源的拥有权； 15.条款15:在资源管理类中提供对原始资源的访问记住：1.API往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法，一般是显示提供get函数；*2.对原始资源的访问可能经由显式转换或者隐式转换。一般而言显示转换更加安全，但是隐式转换对客户会比较方便； 16.条款16:成对使用new和delete时要采取相同的形式当使用new(即通过new动态生成一个对象)，有两件事情发生：1.内存被分配出来（通过名为operator new 的函数）2.针对此内存会有一个（或更多）构造函数被调用。 当使用delete，也有两件事发生：1.针对此内存会有一个（或者更多）析构函数被调用2.之后内存被释放（通过名为operator delete 的函数） 其中delete的最大问题在于：即将被删除的内存之内到底会有多少对象，多少对象决定了会有多少析构函数被调用，因为数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数 同样尽量不要对数组形式做typedef 动作 总结如果在new表达式中使用[],必须在相应的delete表达式中也使用[]如果在new表达式中不使用[],一定不要在相应的delete表达式中使用[]; 17.条款17:以独立语句将newed对象置入智能指针一句话：以独立语句将newed对象存储于智能指针内，即不要融合成一条语句，要分开写，否则编译器分不清语句的执行顺序，一旦异常被抛出，有可能导致难以觉察的资源泄露]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(2)]]></title>
      <url>%2F2017%2F03%2F04%2FEffective-C-2%2F</url>
      <content type="text"><![CDATA[二.构造/析构/赋值运算 5.条款05: 了解C++默默编写并调用哪些函数这是个很重要的问题，我们声明的空类其实“并不空”，当C++处理过之后，如果在类中自己并没有声明任何函数和变量，编译器就会为它声明一个default构造函数，一个copy构造函数，一个析构函数，一个copy assignment操作符，一共四个，当然这些函数都是public且inline 例如我们声明了一个类： class Empty{}; 其实编译器已经替我们做好了许多事，相当于生成下面的代码： class Empty{ public: Empty(){...} Empty(const Empty&amp; this){...} ~Empty(){...} Empty&amp; operator=(const Empty &amp;rhs) {...} }; 因此这样，一个空类的大小并不是0,而是1，那是因为这个空类被编译器插进去的一个char,使得这个class的不同实体(object)在内存中配置是独一无二的，也就是说这个char是用来标识类的不同对象的； 6.条款06: 若不想使用编译器自动生成的函数，就该明确拒绝所有编译器产出的函数都是public，为了阻止这些函数被创建出来。我们需要自行声明它们，同时可将相应的成员函数声明为private并且不予实现。这样即可。 7.条款07: 为多态基类声明virtual析构函数C++明确指出，当继承类对象经由一个基类指针被删除，而该基类带着一个non-virtual析构函数，则结果不明确（通常实际执行时发生的是对象的继承成分没被销毁） virtual 函数的目的是允许derived class 的实现得以客制化；当基类有函数是virtual的，那么它在不同的继承类中会有不同的实现码，任何class只要带有virtual函数都几乎确定应该会有一个virtual析构函数；如果一个class中不含有virtual函数，通常标识它并不试图作为基类，故class不企图被当作base class，尽量不要令析构函数为virtual virtual函数的实现，对象需要带有一些信息，主要用来在运行期间决定哪个virtual函数被调用。这个信息由vptr(virtual table pointer)指针指出。vptr指向一个由函数指针构成的数组，成为vtbl(virtual table)；每个带有virtual函数的class都有一个相应的vtbl。当对象调用某一个virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl—–即编译器在寻找适当的函数指针； 纯虚函数有时可能会更加便利，纯虚函数导致抽象类—-不能被实体化的类。也就是说不可以为这种类创建对象。此时我们需要为抽象的类建立一个纯虚析构函数 class AWOV{ public; virtual ~AWOV() = 0； }; 总结：给基类一个虚析构函数，只适用于带有多态性质的基类身上，这种基类的设计目的是为了用来通过基类接口处理继承类的对象。 8.条款08:别让异常逃离析构函数1.析构函数绝对不要出现异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后处理他们或者结束程序； 2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（不是在析构函数中）执行该操作； 9.条款09:绝不在构造和析构函数中调用virtual函数确定我们的构造函数和析构函数都没有（在对象被创建和销毁期间）调用virtual函数。否则会引起不明确的错误，在初始化期间； 10.条款10:令operator= 返回一个reference to *this令赋值操作符返回一个 reference to *this。 class Widget{ public: ... Widget&amp; operator= (const Widget &amp;rhs){ ... return *this; } ... }; 11.条款11:在operator=中处理“自我赋值”1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址精心周到的语句顺序、以及copy-and-swap。 2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确； 其中还有一点自测行为的使用 if(this == &amp;rhs) return *this; 12.条款12:复制对象时勿忘其每一个成分这个针对复制构造函数和重载赋值操作符，当我们创建一个基类，并创建复制构造函数和重载了赋值操作符，同理它的继承类中创建了自己独有的数据成员，当在继承类中调用赋值构造函数时，我们如果只赋值了继承类中独有的数据成员，却没有对基类的成员进行任何操作，那么继承类中的继承基类的成员只能通过基类的构造函数来初始化。 所以，任何时候都需要为继承类写复制构造函数，必须很小心的复制基类的成分。那些成分是private的，我们无法直接访问它们，故应该让继承类的复制构造函数调用基类的相应的函数来初始化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(1)]]></title>
      <url>%2F2017%2F03%2F01%2FEffective-C-1%2F</url>
      <content type="text"><![CDATA[最近在公司实习，做的是偏数据分析的事情，用的更多的是Python和Shell去开发和处理一些数据库和分布式系统中的数据，故之前相对熟悉的C++的一些细节和原理有些已经记不清楚了，现在正赶上今年的校招故拾起来再看下，希望对自己寻找工作的过程和将来的职业生涯都有帮助；更重要的一点是接触的C++时间更长些，还是没有研究的很深入，所以再读一遍之前看过的书，复习一下，希望有更深的理解！ 一.让自己习惯C++1.条款01：视C++为一个语言联邦一开始，C++只是C上加一些面向对象的特征。故C++最初的名称 C with Classes,但是C++并非一种单一语言，C++ 中各种规则都倾向于简单、直观、容易，因此我们理解C++也有了下面4个最主要的特征：(1) C 说到底C++仍以C为基础，包括 区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型(build-in data types)、数组（arrays）、指针(pointers)都来自C。但是高效的编程守则指出了C的局限：没有模板（templates）,没有异常（exceptions）,没有重载(overloading) (2) Object-Oriented C++ 这一部分是面向对象的精髓坐在：classes(构造函数和析构函数)、封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual 函数（动态绑定）…… (3) Template C++ 这是C++的泛型编程部分，威力非常强大，需要仔细学习 (4) STL STL是template的程序库。它将容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象(fountion-objects)紧密的结合在一起 还有一点，当我们从C转到C++后，pass-by-reference-to-const往往更加好用。C中的pass-by-value同样适用但是性能问题 因此高效编程要视情况而定 ————————————————————————————————————————————— 2.条款02：尽量以const,enum,inline替换 #define这个问题曾经在我面试一个互联网公司时被问到了，当时答的也是不太清晰，尤其是面对原理时。 这个条款根据书中所说可以改成”宁可以编译器替换预处理器”更好，我们在#define 后的记号或许就不就被编译器看到，或许在编译器开始处理源码之前就被预处理器移走了，于是记号就没有进入记号表(symbol table)中。解决的方法就是用一个常量替换上述的宏（const）,作为语言常量，一定会被编译器看到。同时使用const比使用#define导致较小量的码。 针对const替换#define有两种特殊情况： (1) 定义常量指针 由于常量定义式通常在头文件内，因此有必要将指针声明为const,这时使用string比char要优秀： const str::string str(&quot;hello world&quot;); (2) class专属常量 为了将常量的作用于限制于class，这个常量必须定义在class内，而为了此常量没有其他副本，必须将它定义成static成员： class fruit{ private: static const int num; int color[num]; …… }; 同样可以在class内定义，或者class外定义： const int num = 5;我们无法利用#define去创建一个class专属的变量，因为#define并不重视作用域。故不支持封装性 对于#define实现的宏，有时看起来更像函数，但不会有函数调用。这时就需要用inline取替换#define了 总结：对于单纯的常量，最好以const对象或enums替换#define对于形似函数的宏（macros）,最好用inline函数替换#define ————————————————————————————————————————————— 3.条款03: 尽可能使用constconst允许我们指定一个不被改变的对象，同时编译器会强制实施这项约束。const最优是用在面对函数声明时，const可以和函数返回值，各参数，函数自身产生关联。 const成员函数 将const实施于成员函数的目的是为了确认该成员函数可作用于const对象身上，这是很重要的： 这个使class接口比较容易被理解，即哪个函数可以，哪个不可以 它们使”操作const对象”成为了可能 ————————————————————————————————————————————— 4.条款04: 确定对象被使用前已经先被初始化针对将对象初始化，C和C++总是搞得很乱，其实在C++中已经通过default构造函数对对象进行了初始化，但是在non-C part of C++中并没有保障，所以我们的最佳处理就是永远在使用对象之前对它进行初始化，对于无任何成员的内置类型，必须手工完成初始化 理解赋值(assignment)与初始化(initiazation) C++中，对象的成员变量的初始化动作发生在进入构造函数体之前，初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之前，故我们初始化的最佳方法是 成员初值列 fruit::fruit(const str::string &amp;color, const str::string &amp;size){ theColor = color; theSize = size; }； //这是赋值 fruit::fruit(const str::string &amp;color, const str::string &amp;size): theColor(color), theSize(size) {} //这是初始化，通常这个效率更高 规定：总是在初值列中列出所有的成员变量，同时总是使用成员初始化列 C++有着固定的”成员初始化次序”: 基类早于派生类初始化，同时class的成员变量总是以其声明的次序被初始化，无论在初始化列表是什么顺序，所以我们在初始化时尽量与声明的保持一致 针对static对象，寿命在被构造开始到程序结束，即main()函数退出，C++对”定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确的次序，所以这就需要我们在编写程序时加强程序的设计。]]></content>
    </entry>

    
  
  
</search>
