<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[在路上----山东]]></title>
      <url>%2F2017%2F04%2F04%2Ftravel-1%2F</url>
      <content type="text"><![CDATA[“清明时节雨纷纷”，又一个清明节到了，在南方读了大学和研究生，仿佛忘了家里的春天是什么样子，4月的北京雾霾少了，天真的晴朗起来确实还是很美的。趁着清明节的小假期，加上请的两天假，和同学选了个时间比较充裕的地方玩一下—–山东（济南和泰安）。 第一天坐上清晨的高铁去的第一站—-济南。泉城济南，这个城市在我的印象中还停留在初中课本中的文章《济南的冬天》，老舍先生把济南的冬天描述的萧瑟，冷峻。之前从来没去过山东，但印象中的山东人纯朴，老实，毕竟都是孔孟的后代。确实去过之后感觉山东人还是很好的。第一天去了趵突泉，由于是节日人还是挺多的。但是趵突泉没有给我很大的惊喜，或许是时间还没到吧，泉水喷的并不是很冲，但是也能感觉到春天的脚步近了，到处都生机盎然…… 第二天去济南我们都知道要看三大景观，趵突泉，千佛山，大明湖。第二天我们的目的地就是后两者。因为住的宾馆离大明湖比较近，就进去了大明湖。抱着看看”大明湖畔的夏紫薇”,但是始终没有找到，仅仅是围绕着湖的岸边装了一圈，感觉大明湖就是一个人们休闲的大公园，也是这三个景点唯一不需要门票的地方，春天来了还是不错的。 下午去了千佛山，其实赶巧了，正好遇到三月三千佛山庙会，人确实很多；千佛山，顾名思义，山上基本都是佛，但山确实并不高，大概200多米，我们也只是简单爬了下，看了眼济南的全城，感觉济南的雾霾太大了。 在济南呆了两天吧，总体感觉济南这个城市基础建设一般，司机师傅说正在建地铁，但是城市感觉有点乱，街道并不是很干净，但是消费相对较低，人们还是很和蔼的。玩了三个地方，品尝下济南的小吃街，算是不虚此行…… 第三天第三天是重点—-泰山。我们并没有打算去看泰山的日出，最主要的原因是太累，基本上晚上10点前要开始爬山，凌晨3点左右到山顶，觉得这样太累。于是决定就白天上山，体会一下一览众山小的感觉就好了。这样，早上8点多到泰安，做公交直达泰山山脚下开始行程。我们还特意记录了时间，从10：00开始爬；爬泰山分两部分，一是前半部分山脚到中天门，也是比较好爬的一段路程。比较平坦；后半部分从中天门到南天门再到玉皇顶，相对难很多了。尤其是十八盘那段，很陡的山路，基本上都要休息下。其实越是休息越累，这个就是一鼓作气，也是在后半部分泰山的人文景观就开始多了。包括各种名人提的字等，上山时其实不用带干粮，山上的吃的并不贵，这点我们之前没有想到，背着几瓶水登山也是……； 五岳之首，泰山1500多米，确实有种霸气的感觉；泰山以其独特的文化气息在中国山脉届占有重要的地位。当经过疲惫的攀登，到达玉皇顶的那一刻还是感觉异常的兴奋，真的有众山小的感觉。 结束三天的旅行，虽然累，但是心情却是满足的； 其实人生就像一场旅行，在乎的不是目的地，在乎的是沿途的风景以及看风景的心情…… 生活依然前行，旅行还在继续，下一个……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(2)]]></title>
      <url>%2F2017%2F03%2F04%2FEffective-C-2%2F</url>
      <content type="text"><![CDATA[二.构造/析构/赋值运算 5.条款05: 了解C++默默编写并调用哪些函数这是个很重要的问题，我们声明的空类其实“并不空”，当C++处理过之后，如果在类中自己并没有声明任何函数和变量，编译器就会为它声明一个default构造函数，一个copy构造函数，一个析构函数，一个copy assignment操作符，一共四个，当然这些函数都是public且inline 例如我们声明了一个类： class Empty{}; 其实编译器已经替我们做好了许多事，相当于生成下面的代码： class Empty{ public: Empty(){...} Empty(const Empty&amp; this){...} ~Empty(){...} Empty&amp; operator=(const Empty &amp;rhs) {...} }; 因此这样，一个空类的大小并不是0,而是1，那是因为这个空类被编译器插进去的一个char,使得这个class的不同实体(object)在内存中配置是独一无二的，也就是说这个char是用来标识类的不同对象的； 6.条款06: 若不想使用编译器自动生成的函数，就该明确拒绝所有编译器产出的函数都是public，为了阻止这些函数被创建出来。我们需要自行声明它们，同时可将相应的成员函数声明为private并且不予实现。这样即可。 7.条款07: 为多态基类声明virtual析构函数C++明确指出，当继承类对象经由一个基类指针被删除，而该基类带着一个non-virtual析构函数，则结果不明确（通常实际执行时发生的是对象的继承成分没被销毁） virtual 函数的目的是允许derived class 的实现得以客制化；当基类有函数是virtual的，那么它在不同的继承类中会有不同的实现码，任何class只要带有virtual函数都几乎确定应该会有一个virtual析构函数；如果一个class中不含有virtual函数，通常标识它并不试图作为基类，故class不企图被当作base class，尽量不要令析构函数为virtual virtual函数的实现，对象需要带有一些信息，主要用来在运行期间决定哪个virtual函数被调用。这个信息由vptr(virtual table pointer)指针指出。vptr指向一个由函数指针构成的数组，成为vtbl(virtual table)；每个带有virtual函数的class都有一个相应的vtbl。当对象调用某一个virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl—–即编译器在寻找适当的函数指针； 纯虚函数有时可能会更加便利，纯虚函数导致抽象类—-不能被实体化的类。也就是说不可以为这种类创建对象。此时我们需要为抽象的类建立一个纯虚析构函数 class AWOV{ public; virtual ~AWOV() = 0； }; 总结：给基类一个虚析构函数，只适用于带有多态性质的基类身上，这种基类的设计目的是为了用来通过基类接口处理继承类的对象。 8.条款08:别让异常逃离析构函数1.析构函数绝对不要出现异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后处理他们或者结束程序； 2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（不是在析构函数中）执行该操作； 9.条款09:绝不在构造和析构函数中调用virtual函数确定我们的构造函数和析构函数都没有（在对象被创建和销毁期间）调用virtual函数。否则会引起不明确的错误，在初始化期间； 10.条款10:令operator= 返回一个reference to *this令赋值操作符返回一个 reference to *this。 class Widget{ public: ... Widget&amp; operator= (const Widget &amp;rhs){ ... return *this; } ... }; 11.条款11:在operator=中处理“自我赋值”1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址精心周到的语句顺序、以及copy-and-swap。 2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确； 其中还有一点自测行为的使用 if(this == &amp;rhs) return *this; 12.条款12:复制对象时勿忘其每一个成分这个针对复制构造函数和重载赋值操作符，当我们创建一个基类，并创建复制构造函数和重载了赋值操作符，同理它的继承类中创建了自己独有的数据成员，当在继承类中调用赋值构造函数时，我们如果只赋值了继承类中独有的数据成员，却没有对基类的成员进行任何操作，那么继承类中的继承基类的成员只能通过基类的构造函数来初始化。 所以，任何时候都需要为继承类写复制构造函数，必须很小心的复制基类的成分。那些成分是private的，我们无法直接访问它们，故应该让继承类的复制构造函数调用基类的相应的函数来初始化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(1)]]></title>
      <url>%2F2017%2F03%2F01%2FEffective-C-1%2F</url>
      <content type="text"><![CDATA[最近在公司实习，做的是偏数据分析的事情，用的更多的是Python和Shell去开发和处理一些数据库和分布式系统中的数据，故之前相对熟悉的C++的一些细节和原理有些已经记不清楚了，现在正赶上今年的校招故拾起来再看下，希望对自己寻找工作的过程和将来的职业生涯都有帮助；更重要的一点是接触的C++时间更长些，还是没有研究的很深入，所以再读一遍之前看过的书，复习一下，希望有更深的理解！ 一.让自己习惯C++1.条款01：视C++为一个语言联邦一开始，C++只是C上加一些面向对象的特征。故C++最初的名称 C with Classes,但是C++并非一种单一语言，C++ 中各种规则都倾向于简单、直观、容易，因此我们理解C++也有了下面4个最主要的特征：(1) C 说到底C++仍以C为基础，包括 区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型(build-in data types)、数组（arrays）、指针(pointers)都来自C。但是高效的编程守则指出了C的局限：没有模板（templates）,没有异常（exceptions）,没有重载(overloading) (2) Object-Oriented C++ 这一部分是面向对象的精髓坐在：classes(构造函数和析构函数)、封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual 函数（动态绑定）…… (3) Template C++ 这是C++的泛型编程部分，威力非常强大，需要仔细学习 (4) STL STL是template的程序库。它将容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象(fountion-objects)紧密的结合在一起 还有一点，当我们从C转到C++后，pass-by-reference-to-const往往更加好用。C中的pass-by-value同样适用但是性能问题 因此高效编程要视情况而定 ————————————————————————————————————————————— 2.条款02：尽量以const,enum,inline替换 #define这个问题曾经在我面试一个互联网公司时被问到了，当时答的也是不太清晰，尤其是面对原理时。 这个条款根据书中所说可以改成”宁可以编译器替换预处理器”更好，我们在#define 后的记号或许就不就被编译器看到，或许在编译器开始处理源码之前就被预处理器移走了，于是记号就没有进入记号表(symbol table)中。解决的方法就是用一个常量替换上述的宏（const）,作为语言常量，一定会被编译器看到。同时使用const比使用#define导致较小量的码。 针对const替换#define有两种特殊情况： (1) 定义常量指针 由于常量定义式通常在头文件内，因此有必要将指针声明为const,这时使用string比char要优秀： const str::string str(&quot;hello world&quot;); (2) class专属常量 为了将常量的作用于限制于class，这个常量必须定义在class内，而为了此常量没有其他副本，必须将它定义成static成员： class fruit{ private: static const int num; int color[num]; …… }; 同样可以在class内定义，或者class外定义： const int num = 5;我们无法利用#define去创建一个class专属的变量，因为#define并不重视作用域。故不支持封装性 对于#define实现的宏，有时看起来更像函数，但不会有函数调用。这时就需要用inline取替换#define了 总结：对于单纯的常量，最好以const对象或enums替换#define对于形似函数的宏（macros）,最好用inline函数替换#define ————————————————————————————————————————————— 3.条款03: 尽可能使用constconst允许我们指定一个不被改变的对象，同时编译器会强制实施这项约束。const最优是用在面对函数声明时，const可以和函数返回值，各参数，函数自身产生关联。 const成员函数 将const实施于成员函数的目的是为了确认该成员函数可作用于const对象身上，这是很重要的： 这个使class接口比较容易被理解，即哪个函数可以，哪个不可以 它们使”操作const对象”成为了可能 ————————————————————————————————————————————— 4.条款04: 确定对象被使用前已经先被初始化针对将对象初始化，C和C++总是搞得很乱，其实在C++中已经通过default构造函数对对象进行了初始化，但是在non-C part of C++中并没有保障，所以我们的最佳处理就是永远在使用对象之前对它进行初始化，对于无任何成员的内置类型，必须手工完成初始化 理解赋值(assignment)与初始化(initiazation) C++中，对象的成员变量的初始化动作发生在进入构造函数体之前，初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之前，故我们初始化的最佳方法是 成员初值列 fruit::fruit(const str::string &amp;color, const str::string &amp;size){ theColor = color; theSize = size; }； //这是赋值 fruit::fruit(const str::string &amp;color, const str::string &amp;size): theColor(color), theSize(size) {} //这是初始化，通常这个效率更高 规定：总是在初值列中列出所有的成员变量，同时总是使用成员初始化列 C++有着固定的”成员初始化次序”: 基类早于派生类初始化，同时class的成员变量总是以其声明的次序被初始化，无论在初始化列表是什么顺序，所以我们在初始化时尽量与声明的保持一致 针对static对象，寿命在被构造开始到程序结束，即main()函数退出，C++对”定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确的次序，所以这就需要我们在编写程序时加强程序的设计。]]></content>
    </entry>

    
  
  
</search>
