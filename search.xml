<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记]]></title>
      <url>%2F2017%2F03%2F01%2FEffective-C-1%2F</url>
      <content type="text"><![CDATA[最近在公司实习，做的是偏数据分析的事情，用的更多的是Python和Shell去开发和处理一些数据库和分布式系统中的数据，故之前相对熟悉的C++的一些细节和原理有些已经记不清楚了，现在正赶上今年的校招故拾起来再看下，希望对自己寻找工作的过程和将来的职业生涯都有帮助；更重要的一点是接触的C++时间更长些，还是没有研究的很深入，所以再读一遍之前看过的书，复习一下，希望有更深的理解！ #一.让自己习惯C++ ##1.条款01：视C++为一个语言联邦一开始，C++只是C上加一些面向对象的特征。故C++最初的名称 C with Classes,但是C++并非一种单一语言，C++ 中各种规则都倾向于简单、直观、容易，因此我们理解C++也有了下面4个最主要的特征： (1) C 说到底C++仍以C为基础，包括 区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型(build-in data types)、数组（arrays）、指针(pointers)都来自C。但是高效的编程守则指出了C的局限：没有模板（templates）,没有异常（exceptions）,没有重载(overloading) (2) Object-Oriented C++ 这一部分是面向对象的精髓坐在：classes(构造函数和析构函数)、封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual 函数（动态绑定）…… (3) Template C++ 这是C++的泛型编程部分，威力非常强大，需要仔细学习 (4) STL STL是template的程序库。它将容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象(fountion-objects)紧密的结合在一起 还有一点，当我们从C转到C++后，pass-by-reference-to-const往往更加好用。C中的pass-by-value同样适用但是性能问题 因此高效编程要视情况而定 ————————————————————————————————————————————— ##2.条款02：尽量以const,enum,inline替换 #define这个问题曾经在我面试一个互联网公司时被问到了，当时答的也是不太清晰，尤其是面对原理时。 这个条款根据书中所说可以改成”宁可以编译器替换预处理器”更好，我们在#define 后的记号或许就不就被编译器看到，或许在编译器开始处理源码之前就被预处理器移走了，于是记号就没有进入记号表(symbol table)中。解决的方法就是用一个常量替换上述的宏（const）,作为语言常量，一定会被编译器看到。同时使用const比使用#define导致较小量的码。 针对const替换#define有两种特殊情况： (1) 定义常量指针 由于常量定义式通常在头文件内，因此有必要将指针声明为const,这时使用string比char要优秀： const str::string str(&quot;hello world&quot;); (2) class专属常量 为了将常量的作用于限制于class，这个常量必须定义在class内，而为了此常量没有其他副本，必须将它定义成static成员： class fruit{ private: static const int num; int color[num]; …… }; 同样可以在class内定义，或者class外定义： const int num = 5;我们无法利用#define去创建一个class专属的变量，因为#define并不重视作用域。故不支持封装性 对于#define实现的宏，有时看起来更像函数，但不会有函数调用。这时就需要用inline取替换D#define了 总结： 对于单纯的常量，最好以const对象或enums替换#define 对于形似函数的宏（macros）,最好用inline函数替换#define ##3.条款03尽可能使用const const允许我们指定一个不被改变的对象，同时编译器会强制实施这项约束。const最优是用在面对函数声明时，const可以和函数返回值，各参数，函数自身产生关联。 const成员函数 将const实施于成员函数的目的是为了确认该成员函数可作用于const对象身上，这是很重要的： 这个使class接口比较容易被理解，即哪个函数可以，哪个不可以 它们使”操作const对象”成为了可能 ##4.条款04确定对象被使用前已经先被初始化 针对将对象初始化，C和C++总是搞得很乱，其实在C++中已经通过default构造函数对对象进行了初始化，但是在non-C part of C++中并没有保障，所以我们的最佳处理就是永远在使用对象之前对它进行初始化，对于无任何成员的内置类型，必须手工完成初始化 理解赋值(assignment)与初始化(initiazation) C++中，对象的成员变量的初始化动作发生在进入构造函数体之前，初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之前，故我们初始化的最佳方法是 成员初值列 fruit::fruit(const str::string &amp;color, const str::string &amp;size){ theColor = color; theSize = size; }； //这是赋值 fruit::fruit(const str::string &amp;color, const str::string &amp;size): theColor(color), theSize(size) {} //这是初始化，通常这个效率更高 规定：总是在初值列中列出所有的成员变量，同时总是使用成员初始化列 C++有着固定的”成员初始化次序”: 基类早于派生类初始化，同时class的成员变量总是以其声明的次序被初始化，无论在初始化列表是什么顺序，所以我们在初始化时尽量与声明的保持一致 针对static对象，寿命在被构造开始到程序结束，即main()函数退出，C++对”定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确的次序，所以这就需要我们在编写程序时加强程序的设计。]]></content>
    </entry>

    
  
  
</search>
