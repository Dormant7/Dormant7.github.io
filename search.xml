<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[我们都是大城市的乞讨者]]></title>
      <url>%2F2017%2F05%2F18%2Fthinking-1%2F</url>
      <content type="text"><![CDATA[—纪念自己实习的那些日子 当年上学时不知道什么是北漂 直到自己做了这样一个熟悉又陌生的群体中的一员 才深有感觉 来北京实习已经整整一年了 去年的5月18号是个特别的日子 来到北京入职的第一天 住到自己租的房子的第一天 认识很重要的一个人的第一天 一年来实习了两家优秀的公司 认识了不少圈里的朋友 也看到了白天的摩天大楼 和夜晚的三轮，地摊 北京，是不是充满了梦想 我不了解 在这里 不能比学历 总有比你更高的学历 不能比财富 总有比你挣得更多，更轻松的 只能比勤奋 因为我们每个人心里都有 只要坚持，努力 我们会活出我们想成为的样子 可是，是这样吗？ 我们都是大城市的乞讨者 怀揣着微不足道的信心 在这个浮躁的时代 能保持初心，善心，耐心，真的很重要 还能怎样，一步步走下去吧 欣赏着人和事……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[讲不出再见]]></title>
      <url>%2F2017%2F04%2F27%2Ftravel-2%2F</url>
      <content type="text"><![CDATA[回国也有几天了，疲倦还未消散，在巴厘岛的一幕幕也很难在头脑中散去晚上闭上窗帘，拉开心里的序幕总希望快乐环绕，但……我们管过去的叫做最美好的时光我想，当某天无端想起某些人，某些事一定会出现在明天里因为我讲不出再见！ 那天是清晨，没睡，心情依然快乐 巴厘岛的海滩还不错没有一点污染让人心里自然感觉纯净，豁然开朗 巴厘岛的水底真的很清澈人类还是征服不了自然 当地的大餐，我却不怎么喜欢不过还是有点诱人的吧 行程紧密，但很充实感谢团队中的每一个人，带给我快乐和帮助 希望我们的友谊长存希望无论天涯何处，莫要相忘 当然总要走真的一米之遥，或许两岸相隔生活还要继续望各自珍重望……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[孔孟之乡]]></title>
      <url>%2F2017%2F04%2F04%2Ftravel-1%2F</url>
      <content type="text"><![CDATA[“清明时节雨纷纷”，又一个清明节到了，在南方读了大学和研究生，仿佛忘了家里的春天是什么样子，4月的北京雾霾少了，天真的晴朗起来确实还是很美的。趁着清明节的小假期，加上请的两天假，和同学选了个时间比较充裕的地方玩一下—–山东（济南和泰安）。 第一天坐上清晨的高铁去的第一站—-济南。泉城济南，这个城市在我的印象中还停留在初中课本中的文章《济南的冬天》，老舍先生把济南的冬天描述的萧瑟，冷峻。之前从来没去过山东，但印象中的山东人纯朴，老实，毕竟都是孔孟的后代。确实去过之后感觉山东人还是很好的。第一天去了趵突泉，由于是节日人还是挺多的。但是趵突泉没有给我很大的惊喜，或许是时间还没到吧，泉水喷的并不是很冲，但是也能感觉到春天的脚步近了，到处都生机盎然…… 第二天去济南我们都知道要看三大景观，趵突泉，千佛山，大明湖。第二天我们的目的地就是后两者。因为住的宾馆离大明湖比较近，就进去了大明湖。抱着看看”大明湖畔的夏紫薇”,但是始终没有找到，仅仅是围绕着湖的岸边装了一圈，感觉大明湖就是一个人们休闲的大公园，也是这三个景点唯一不需要门票的地方，春天来了还是不错的。 下午去了千佛山，其实赶巧了，正好遇到三月三千佛山庙会，人确实很多；千佛山，顾名思义，山上基本都是佛，但山确实并不高，大概200多米，我们也只是简单爬了下，看了眼济南的全城，感觉济南的雾霾太大了。 在济南呆了两天吧，总体感觉济南这个城市基础建设一般，司机师傅说正在建地铁，但是城市感觉有点乱，街道并不是很干净，但是消费相对较低，人们还是很和蔼的。玩了三个地方，品尝下济南的小吃街，算是不虚此行…… 第三天第三天是重点—-泰山。我们并没有打算去看泰山的日出，最主要的原因是太累，基本上晚上10点前要开始爬山，凌晨3点左右到山顶，觉得这样太累。于是决定就白天上山，体会一下一览众山小的感觉就好了。这样，早上8点多到泰安，做公交直达泰山山脚下开始行程。我们还特意记录了时间，从10：00开始爬；爬泰山分两部分，一是前半部分山脚到中天门，也是比较好爬的一段路程。比较平坦；后半部分从中天门到南天门再到玉皇顶，相对难很多了。尤其是十八盘那段，很陡的山路，基本上都要休息下。其实越是休息越累，这个就是一鼓作气，也是在后半部分泰山的人文景观就开始多了。包括各种名人提的字等，上山时其实不用带干粮，山上的吃的并不贵，这点我们之前没有想到，背着几瓶水登山也是……； 五岳之首，泰山1500多米，确实有种霸气的感觉；泰山以其独特的文化气息在中国山脉届占有重要的地位。当经过疲惫的攀登，到达玉皇顶的那一刻还是感觉异常的兴奋，真的有众山小的感觉。 结束三天的旅行，虽然累，但是心情却是满足的； 其实人生就像一场旅行，在乎的不是目的地，在乎的是沿途的风景以及看风景的心情…… 生活依然前行，旅行还在继续，下一个……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(4)]]></title>
      <url>%2F2017%2F03%2F08%2FEffective-C-4%2F</url>
      <content type="text"><![CDATA[四.设计与声明 18.条款18:让接口容易被正确使用，不易被误用 记住以下几点即可：1.好的接口很容易被正确使用，不容易被误用，我们需要在我们的所有接口中努力达成这些性质；2.正确使用接口的办法包括接口的一致性，以及与内置类型的行为兼容；3.防止误用的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。4.tr1::shared_ptr支持定制型删除器。这可防止DLL问题，可被用来自动解除互斥锁等等； 19.条款19:设计class犹如设计type这个条款需要记住，当定义一个新的class，也就定义了一个新的type。这就意味着我们重载函数和操作符，控制内存的分配和归还，定义对象的初始化和终结……都掌握在我们自己的手上。 m m所以设计一个优秀的class是一项艰巨的任务。 20.条款20:宁以pass-by-reference-to-const替换pass-by-value这个条款很重要 缺省情况下C++以by value方式传递对象到函数，这样函数参数都是以实际参数的副本为初值，这些副本也是由对象的copy构造函数产出，这就使得pass-by-value成为昂贵的操作； 基于此，有两点好处需要详解例一： class Person { public: Person(); virtual ~Person(); ... private: std::string name; std::string address; }; class Student:public Person { public: Student(); ~Student(); ... private: std::string schoolName; std::string schoolAddress; }; 考虑这样的情况，调用函数validateStudent，这个函数需要一个Student的参数（by value）， bool validateStudent （Student s）; //函数接受一个by value的参数 Student plato； bool platoIsOK = validateStudent(plato); //调用函数 看一下吧。无疑，Student的copy构造函数会被调用，加上validataStudent返回s会被销毁，因此参数传递的成本是一次copy函数调用，一次Student析构函数调用； 这只是简单的一点，当我们深入去研究会发现，Student有两个string对象，所以每次构造Student同时也构造了两个string对象，同时Student对象继承字Person，Person中也有两个string对象，也需要构造两个string对象，最终结果是以by value传递参数会有一次Student copy构造函数，一次Person copy构造函数，4次string copy 构造函数，当销毁时伴随着6次析构的过程。所以一共是6次copy构造，6次析构； 这样为避免如此多的消耗，我们需要用pass by reference-to-const这种传递方式效率要高很多：没有任何构造函数和析构函数被调用，因为没有任何新对象呗创建，但是这里的const是必要的，原来的by value 传递的是副本，无论怎么修改源对象时不变的，这里却不同了，所以加上const是必要的。 例二：以by reference 方式传递参数可以避免slicing(对象切割)问题。就是说，当一个继承类对象以by value的方式传递并被视作一个基类对象，基类的copy 构造函数会被调用，从而造成本来是针对继承类的对象的性质全被切割掉了，仅仅留下了一个基类对象。 class Windows { public: ... std::string name() const; virtual void display() const; //实现方式1 }; class WindowsWithScrollBars:public Windows { public: ... virtual void display() const; //实现方式2 }; 现在我们需要打印窗口名称和显示窗口，这个是错误的 void printNameAndDisplay(Windows w){ std::cout &lt;&lt;w.name(); w.display(); } 当我们传递给函数一个WindowWithScrollBars对象 WindowEithScrollBars wwsb; printNameAndDisplay(wwsb); 参数w会百构造成一个Windows对象，因为这个是pass by value，这个WindowEithScrollBars对象的特有的信息会被切除；在printNameAndDisplay中无论传进来的对象原本是是什么类型，参数w都会被强制转化成Window对象，因此函数中调用display(),永远是调用Window::display(); 解决这个问题的方式就是 by reference-to-const 这样参数不会被切割，传进来什么类型就表现什么类型； 当我们审视C++编译器的底层，会发现references往往是以指针实现出来的，因此pass by reference通常意味着传递指针。但当对象时内置类型时，pass by value 却比 pass by reference效率更高，同时这个tip也适用于STL的迭代器和函数对象，习惯上这些都被设计成pass by value 总结 1.尽量以pass-by-reference-to-const 替换pass-by-value前者通常比较高效，并可避免切割问题；2.但针对内置类型，STL的迭代器和函数对象，pass-by-value更加高效； 21.条款21:必须返回对象时，别妄想返回其reference任何时候看到一个reference声明式，你都应该立刻问自己，它的另一个名称是什么，因为它一定是某物的另一个名称。例如operator*为例，如果它返回一个reference，后者一定指向某个既有的对象，内含两个对象的乘积； 总结下来就是： 绝对不要返回pointer或者reference指向一个local stack 对象，或返回reference指向一个heap-allocated对象，或者返回pointer或reference指向一个local static 对象而有可能同时需要多个这样的对象 22.条款22:将成员变量声明为private总结起来： 1.一定要将成员变量声明为private,这样能赋予客户访问数据的一致性，允许约束条件获得保障，并提供class作者以充分的实现弹性； 2.protected并不比public更具封装性； 23.条款23:宁以non-menber，non-friend替换menber函数要以non-member， non-freend函数替换member函数，这样做可以增加封装性，包裹弹性，和机能扩充性； 24.条款24:若所有参数皆需要类型转换，请为此采用non-menber函数如果需要为某个函数的所有参数进行类型转换，那么这个函数必须是个non-member函数，尤其是针对操作符重载 25.条款25:考虑写出一个不抛出异常的swap函数总结1.当std::swap 对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常；2.如果你提供一个member swap ,也该提供一个non-member swap 用来调用前者。对于classes(而非templates),也请特化std::swap;3.调用swap时应对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”；4.为“用户定义类型”进行谁提的templates全特化是好的，但不要在std内加入某些对std而言全新的东西]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(3)]]></title>
      <url>%2F2017%2F03%2F06%2FEffective-C-3%2F</url>
      <content type="text"><![CDATA[三.资源管理 13.条款13:以对象管理资源在C++中，动态分配的内存是需要我们手动去释放掉的，否则就会造成内存泄漏。把资源放进对象内，我们便可以依赖C++的“析构函数”自动调用机制，确保资源被释放。 于是有两个关键的想法：1.获得资源后立刻放进管理对象 资源取得时机就是初始化时机（RAII）2.管理对象运用析构函数确保资源被释放标准库中提供的智能指针，auto_ptr,tr1::shared_ptrs就是在其析构函数内做delete，但不是delete[]，故在动态分配得到的array中使用这两者并不适用 总结1.为防止资源泄露，应使用RAII对象，他们在构造函数中获得资源并在析构函数中释放资源；2.两个常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向NULL。 14.条款14:在资源管理类中小心copy行为这个情况是面对当一个RAII对象被复制时，会发生什么？多数情况会有以下几种可能：1.禁止复制；将copying操作声明为private。2.对底层资源应用“引用计数法”，例如：tr1::shared_ptr3.复制底部资源；复制底部资源管理对象时，进行的是深拷贝4.转移底部资源的拥有权； 15.条款15:在资源管理类中提供对原始资源的访问记住：1.API往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法，一般是显示提供get函数；*2.对原始资源的访问可能经由显式转换或者隐式转换。一般而言显示转换更加安全，但是隐式转换对客户会比较方便； 16.条款16:成对使用new和delete时要采取相同的形式当使用new(即通过new动态生成一个对象)，有两件事情发生：1.内存被分配出来（通过名为operator new 的函数）2.针对此内存会有一个（或更多）构造函数被调用。 当使用delete，也有两件事发生：1.针对此内存会有一个（或者更多）析构函数被调用2.之后内存被释放（通过名为operator delete 的函数） 其中delete的最大问题在于：即将被删除的内存之内到底会有多少对象，多少对象决定了会有多少析构函数被调用，因为数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数 同样尽量不要对数组形式做typedef 动作 总结如果在new表达式中使用[],必须在相应的delete表达式中也使用[]如果在new表达式中不使用[],一定不要在相应的delete表达式中使用[]; 17.条款17:以独立语句将newed对象置入智能指针一句话：以独立语句将newed对象存储于智能指针内，即不要融合成一条语句，要分开写，否则编译器分不清语句的执行顺序，一旦异常被抛出，有可能导致难以觉察的资源泄露]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(2)]]></title>
      <url>%2F2017%2F03%2F04%2FEffective-C-2%2F</url>
      <content type="text"><![CDATA[二.构造/析构/赋值运算 5.条款05: 了解C++默默编写并调用哪些函数这是个很重要的问题，我们声明的空类其实“并不空”，当C++处理过之后，如果在类中自己并没有声明任何函数和变量，编译器就会为它声明一个default构造函数，一个copy构造函数，一个析构函数，一个copy assignment操作符，一共四个，当然这些函数都是public且inline 例如我们声明了一个类： class Empty{}; 其实编译器已经替我们做好了许多事，相当于生成下面的代码： class Empty{ public: Empty(){...} Empty(const Empty&amp; this){...} ~Empty(){...} Empty&amp; operator=(const Empty &amp;rhs) {...} }; 因此这样，一个空类的大小并不是0,而是1，那是因为这个空类被编译器插进去的一个char,使得这个class的不同实体(object)在内存中配置是独一无二的，也就是说这个char是用来标识类的不同对象的； 6.条款06: 若不想使用编译器自动生成的函数，就该明确拒绝所有编译器产出的函数都是public，为了阻止这些函数被创建出来。我们需要自行声明它们，同时可将相应的成员函数声明为private并且不予实现。这样即可。 7.条款07: 为多态基类声明virtual析构函数C++明确指出，当继承类对象经由一个基类指针被删除，而该基类带着一个non-virtual析构函数，则结果不明确（通常实际执行时发生的是对象的继承成分没被销毁） virtual 函数的目的是允许derived class 的实现得以客制化；当基类有函数是virtual的，那么它在不同的继承类中会有不同的实现码，任何class只要带有virtual函数都几乎确定应该会有一个virtual析构函数；如果一个class中不含有virtual函数，通常标识它并不试图作为基类，故class不企图被当作base class，尽量不要令析构函数为virtual virtual函数的实现，对象需要带有一些信息，主要用来在运行期间决定哪个virtual函数被调用。这个信息由vptr(virtual table pointer)指针指出。vptr指向一个由函数指针构成的数组，成为vtbl(virtual table)；每个带有virtual函数的class都有一个相应的vtbl。当对象调用某一个virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl—–即编译器在寻找适当的函数指针； 纯虚函数有时可能会更加便利，纯虚函数导致抽象类—-不能被实体化的类。也就是说不可以为这种类创建对象。此时我们需要为抽象的类建立一个纯虚析构函数 class AWOV{ public; virtual ~AWOV() = 0； }; 总结：给基类一个虚析构函数，只适用于带有多态性质的基类身上，这种基类的设计目的是为了用来通过基类接口处理继承类的对象。 8.条款08:别让异常逃离析构函数1.析构函数绝对不要出现异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后处理他们或者结束程序； 2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（不是在析构函数中）执行该操作； 9.条款09:绝不在构造和析构函数中调用virtual函数确定我们的构造函数和析构函数都没有（在对象被创建和销毁期间）调用virtual函数。否则会引起不明确的错误，在初始化期间； 10.条款10:令operator= 返回一个reference to *this令赋值操作符返回一个 reference to *this。 class Widget{ public: ... Widget&amp; operator= (const Widget &amp;rhs){ ... return *this; } ... }; 11.条款11:在operator=中处理“自我赋值”1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址精心周到的语句顺序、以及copy-and-swap。 2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确； 其中还有一点自测行为的使用 if(this == &amp;rhs) return *this; 12.条款12:复制对象时勿忘其每一个成分这个针对复制构造函数和重载赋值操作符，当我们创建一个基类，并创建复制构造函数和重载了赋值操作符，同理它的继承类中创建了自己独有的数据成员，当在继承类中调用赋值构造函数时，我们如果只赋值了继承类中独有的数据成员，却没有对基类的成员进行任何操作，那么继承类中的继承基类的成员只能通过基类的构造函数来初始化。 所以，任何时候都需要为继承类写复制构造函数，必须很小心的复制基类的成分。那些成分是private的，我们无法直接访问它们，故应该让继承类的复制构造函数调用基类的相应的函数来初始化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective C++ 阅读笔记(1)]]></title>
      <url>%2F2017%2F03%2F01%2FEffective-C-1%2F</url>
      <content type="text"><![CDATA[最近在公司实习，做的是偏数据分析的事情，用的更多的是Python和Shell去开发和处理一些数据库和分布式系统中的数据，故之前相对熟悉的C++的一些细节和原理有些已经记不清楚了，现在正赶上今年的校招故拾起来再看下，希望对自己寻找工作的过程和将来的职业生涯都有帮助；更重要的一点是接触的C++时间更长些，还是没有研究的很深入，所以再读一遍之前看过的书，复习一下，希望有更深的理解！ 一.让自己习惯C++1.条款01：视C++为一个语言联邦一开始，C++只是C上加一些面向对象的特征。故C++最初的名称 C with Classes,但是C++并非一种单一语言，C++ 中各种规则都倾向于简单、直观、容易，因此我们理解C++也有了下面4个最主要的特征：(1) C 说到底C++仍以C为基础，包括 区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型(build-in data types)、数组（arrays）、指针(pointers)都来自C。但是高效的编程守则指出了C的局限：没有模板（templates）,没有异常（exceptions）,没有重载(overloading) (2) Object-Oriented C++ 这一部分是面向对象的精髓坐在：classes(构造函数和析构函数)、封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual 函数（动态绑定）…… (3) Template C++ 这是C++的泛型编程部分，威力非常强大，需要仔细学习 (4) STL STL是template的程序库。它将容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象(fountion-objects)紧密的结合在一起 还有一点，当我们从C转到C++后，pass-by-reference-to-const往往更加好用。C中的pass-by-value同样适用但是性能问题 因此高效编程要视情况而定 ————————————————————————————————————————————— 2.条款02：尽量以const,enum,inline替换 #define这个问题曾经在我面试一个互联网公司时被问到了，当时答的也是不太清晰，尤其是面对原理时。 这个条款根据书中所说可以改成”宁可以编译器替换预处理器”更好，我们在#define 后的记号或许就不就被编译器看到，或许在编译器开始处理源码之前就被预处理器移走了，于是记号就没有进入记号表(symbol table)中。解决的方法就是用一个常量替换上述的宏（const）,作为语言常量，一定会被编译器看到。同时使用const比使用#define导致较小量的码。 针对const替换#define有两种特殊情况： (1) 定义常量指针 由于常量定义式通常在头文件内，因此有必要将指针声明为const,这时使用string比char要优秀： const str::string str(&quot;hello world&quot;); (2) class专属常量 为了将常量的作用于限制于class，这个常量必须定义在class内，而为了此常量没有其他副本，必须将它定义成static成员： class fruit{ private: static const int num; int color[num]; …… }; 同样可以在class内定义，或者class外定义： const int num = 5;我们无法利用#define去创建一个class专属的变量，因为#define并不重视作用域。故不支持封装性 对于#define实现的宏，有时看起来更像函数，但不会有函数调用。这时就需要用inline取替换#define了 总结：对于单纯的常量，最好以const对象或enums替换#define对于形似函数的宏（macros）,最好用inline函数替换#define ————————————————————————————————————————————— 3.条款03: 尽可能使用constconst允许我们指定一个不被改变的对象，同时编译器会强制实施这项约束。const最优是用在面对函数声明时，const可以和函数返回值，各参数，函数自身产生关联。 const成员函数 将const实施于成员函数的目的是为了确认该成员函数可作用于const对象身上，这是很重要的： 这个使class接口比较容易被理解，即哪个函数可以，哪个不可以 它们使”操作const对象”成为了可能 ————————————————————————————————————————————— 4.条款04: 确定对象被使用前已经先被初始化针对将对象初始化，C和C++总是搞得很乱，其实在C++中已经通过default构造函数对对象进行了初始化，但是在non-C part of C++中并没有保障，所以我们的最佳处理就是永远在使用对象之前对它进行初始化，对于无任何成员的内置类型，必须手工完成初始化 理解赋值(assignment)与初始化(initiazation) C++中，对象的成员变量的初始化动作发生在进入构造函数体之前，初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之前，故我们初始化的最佳方法是 成员初值列 fruit::fruit(const str::string &amp;color, const str::string &amp;size){ theColor = color; theSize = size; }； //这是赋值 fruit::fruit(const str::string &amp;color, const str::string &amp;size): theColor(color), theSize(size) {} //这是初始化，通常这个效率更高 规定：总是在初值列中列出所有的成员变量，同时总是使用成员初始化列 C++有着固定的”成员初始化次序”: 基类早于派生类初始化，同时class的成员变量总是以其声明的次序被初始化，无论在初始化列表是什么顺序，所以我们在初始化时尽量与声明的保持一致 针对static对象，寿命在被构造开始到程序结束，即main()函数退出，C++对”定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确的次序，所以这就需要我们在编写程序时加强程序的设计。]]></content>
    </entry>

    
  
  
</search>
