<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有家客栈</title>
  <subtitle>我也看到了，他好像条狗哎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-20T07:42:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Dormant7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我们都是大城市的乞讨者</title>
    <link href="http://yoursite.com/2017/05/18/thinking-1/"/>
    <id>http://yoursite.com/2017/05/18/thinking-1/</id>
    <published>2017-05-17T16:00:00.000Z</published>
    <updated>2017-05-20T07:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="—纪念自己实习的那些日子"><a href="#—纪念自己实习的那些日子" class="headerlink" title="—纪念自己实习的那些日子"></a>—纪念自己实习的那些日子</h2><a id="more"></a>
<hr>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=5255464&auto=1&height=32"></iframe></p>
<hr>
<p><strong>当年上学时不知道什么是北漂</strong></p>
<p><strong>直到自己做了这样一个熟悉又陌生的群体中的一员</strong></p>
<p><strong>才深有感觉</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffrtza05rhj31kw11x4bg.jpg" alt=""></p>
<p><strong>来北京实习已经整整一年了</strong></p>
<p><strong>去年的5月18号是个特别的日子</strong></p>
<p><strong>来到北京入职的第一天</strong></p>
<p><strong>住到自己租的房子的第一天</strong></p>
<p><strong>认识很重要的一个人的第一天</strong></p>
<p><strong>一年来实习了两家优秀的公司</strong></p>
<p><strong>认识了不少圈里的朋友</strong></p>
<p><strong>也看到了白天的摩天大楼</strong></p>
<p><strong>和夜晚的三轮，地摊</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffru9tb136j31kw0w00zy.jpg" alt=""></p>
<p><strong>北京，是不是充满了梦想</strong></p>
<p><strong>我不了解</strong></p>
<p><strong>在这里</strong></p>
<p><strong>不能比学历</strong></p>
<p><strong>总有比你更高的学历</strong></p>
<p><strong>不能比财富</strong></p>
<p><strong>总有比你挣得更多，更轻松的</strong></p>
<p><strong>只能比勤奋</strong></p>
<p><strong>因为我们每个人心里都有</strong></p>
<p><strong>只要坚持，努力</strong></p>
<p><strong>我们会活出我们想成为的样子</strong></p>
<p><strong>可是，是这样吗？</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffrujaxe3sj31kw11zqey.jpg" alt=""></p>
<p><strong>我们都是大城市的乞讨者</strong></p>
<p><strong>怀揣着微不足道的信心</strong></p>
<p><strong>在这个浮躁的时代</strong></p>
<p><strong>能保持初心，善心，耐心，真的很重要</strong></p>
<p><strong>还能怎样，一步步走下去吧</strong></p>
<p><strong>欣赏着人和事……</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffrv1be7smj31kw11xtnw.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;—纪念自己实习的那些日子&quot;&gt;&lt;a href=&quot;#—纪念自己实习的那些日子&quot; class=&quot;headerlink&quot; title=&quot;—纪念自己实习的那些日子&quot;&gt;&lt;/a&gt;—纪念自己实习的那些日子&lt;/h2&gt;
    
    </summary>
    
      <category term="经历" scheme="http://yoursite.com/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="经历" scheme="http://yoursite.com/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>讲不出再见</title>
    <link href="http://yoursite.com/2017/04/27/travel-2/"/>
    <id>http://yoursite.com/2017/04/27/travel-2/</id>
    <published>2017-04-26T16:00:00.000Z</published>
    <updated>2017-05-02T08:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ff7302pm2vj30zk0qo76b.jpg" alt=""></p>
<a id="more"></a>
<p><strong>回国也有几天了，疲倦还未消散，在巴厘岛的一幕幕也很难在头脑中散去</strong><br><strong>晚上</strong><br><strong>闭上窗帘，拉开心里的序幕</strong><br><strong>总希望快乐环绕，但……</strong><br><strong>我们管过去的</strong><br><strong>叫做最美好的时光</strong><br><strong>我想，当某天无端想起某些人，某些事</strong><br><strong>一定会出现在明天里</strong><br><strong>因为我讲不出再见！</strong></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=152392&auto=1&height=66"></iframe>

<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ff5ycagr1vj30qo0zkt98.jpg" alt="" title="出发了"></p>
<p><strong>那天是清晨，没睡，心情依然快乐</strong></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ff5yjv42gvj31kw11xb29.jpg" alt="" title="海洋"></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ff5yqtb57aj30zk0qot9f.jpg" alt="" title="海洋"></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1ff5yrpd47dj30zk0qo40w.jpg" alt="" title="海洋"></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ff71v1hu9rj30qo0zkjuc.jpg" alt="" title="Dream"></p>
<p><strong>巴厘岛的海滩还不错</strong><br><strong>没有一点污染</strong><br><strong>让人心里自然感觉纯净，豁然开朗</strong></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ff5yv0agn0j30qo0zk40s.jpg" alt="" title="好想自由"></p>
<p><strong>巴厘岛的水底真的很清澈</strong><br><strong>人类还是征服不了自然</strong></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1ff71wayp9ij30qo0zkgp3.jpg" alt="" title="大餐"></p>
<p><strong>当地的大餐，我却不怎么喜欢</strong><br><strong>不过还是有点诱人的吧</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ff720giy8bj31kw11xu0x.jpg" alt="" title="我的团队"></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ff720k5n5lj31kw11x7wh.jpg" alt="" title="我的团队"></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1ff721exu24j31kw11xnpd.jpg" alt="" title="我的团队"></p>
<p><strong>行程紧密，但很充实</strong><br><strong>感谢团队中的每一个人，带给我快乐和帮助</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ff724ewc8sj30a006n0sx.jpg" alt="" title="妹子"></p>
<p><strong>希望我们的友谊长存</strong><br><strong>希望无论天涯何处，莫要相忘</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ff7275i8acj30a006n0st.jpg" alt="" title="这样吧"></p>
<p><strong>当然总要走</strong><br><strong>真的一米之遥，或许两岸相隔</strong><br><strong>生活还要继续</strong><br><strong>望各自珍重</strong><br><strong>望……</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1ff7302pm2vj30zk0qo76b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="在路上" scheme="http://yoursite.com/categories/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
    
      <category term="在路上" scheme="http://yoursite.com/tags/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
      <category term="旅行" scheme="http://yoursite.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="朋友" scheme="http://yoursite.com/tags/%E6%9C%8B%E5%8F%8B/"/>
    
      <category term="友谊" scheme="http://yoursite.com/tags/%E5%8F%8B%E8%B0%8A/"/>
    
  </entry>
  
  <entry>
    <title>孔孟之乡</title>
    <link href="http://yoursite.com/2017/04/04/travel-1/"/>
    <id>http://yoursite.com/2017/04/04/travel-1/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-05-02T07:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcly1feb4zo2knfj31kw0w0aej.jpg" alt="" title="在路上"></p>
<hr>
<a id="more"></a>
<p><em><font size="3" face="微软雅黑">“清明时节雨纷纷”，又一个清明节到了，在南方读了大学和研究生，仿佛忘了家里的春天是什么样子，4月的北京雾霾少了，天真的晴朗起来确实还是很美的。趁着清明节的小假期，加上请的两天假，和同学选了个时间比较充裕的地方玩一下—–山东（济南和泰安）。<br></font></em></p>
<hr>
<h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>坐上清晨的高铁去的第一站—-济南。泉城济南，这个城市在我的印象中还停留在初中课本中的文章《济南的冬天》，老舍先生把济南的冬天描述的萧瑟，冷峻。之前从来没去过山东，但印象中的山东人纯朴，老实，毕竟都是孔孟的后代。确实去过之后感觉山东人还是很好的。第一天去了趵突泉，由于是节日人还是挺多的。但是趵突泉没有给我很大的惊喜，或许是时间还没到吧，泉水喷的并不是很冲，但是也能感觉到春天的脚步近了，到处都生机盎然……</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1feb4ujsqxcj30zk0qojvo.jpg" alt="" title="趵突泉"></p>
<h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>去济南我们都知道要看三大景观，趵突泉，千佛山，大明湖。第二天我们的目的地就是后两者。因为住的宾馆离大明湖比较近，就进去了大明湖。抱着看看”大明湖畔的夏紫薇”,但是始终没有找到，仅仅是围绕着湖的岸边装了一圈，感觉大明湖就是一个人们休闲的大公园，也是这三个景点唯一不需要门票的地方，春天来了还是不错的。</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1feb51yueb5j30zk0qo0ur.jpg" alt="" title="大明湖"></p>
<p>下午去了千佛山，其实赶巧了，正好遇到三月三千佛山庙会，人确实很多；千佛山，顾名思义，山上基本都是佛，但山确实并不高，大概200多米，我们也只是简单爬了下，看了眼济南的全城，感觉济南的雾霾太大了。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcly1feb52mw3atj30zk0qojt0.jpg" alt="" title="千佛山"></p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcly1feb535c2pyj30zk0qo773.jpg" alt="" title="济南全城"></p>
<p>在济南呆了两天吧，总体感觉济南这个城市基础建设一般，司机师傅说正在建地铁，但是城市感觉有点乱，街道并不是很干净，但是消费相对较低，人们还是很和蔼的。玩了三个地方，品尝下济南的小吃街，算是不虚此行……</p>
<h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p>第三天是重点—-泰山。我们并没有打算去看泰山的日出，最主要的原因是太累，基本上晚上10点前要开始爬山，凌晨3点左右到山顶，觉得这样太累。于是决定就白天上山，体会一下一览众山小的感觉就好了。这样，早上8点多到泰安，做公交直达泰山山脚下开始行程。我们还特意记录了时间，从10：00开始爬；爬泰山分两部分，一是前半部分山脚到中天门，也是比较好爬的一段路程。比较平坦；后半部分从中天门到南天门再到玉皇顶，相对难很多了。尤其是十八盘那段，很陡的山路，基本上都要休息下。其实越是休息越累，这个就是一鼓作气，也是在后半部分泰山的人文景观就开始多了。包括各种名人提的字等，上山时其实不用带干粮，山上的吃的并不贵，这点我们之前没有想到，背着几瓶水登山也是……；</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1feb54f5m1vj30zk0qoadd.jpg" alt="" title="中天门"></p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1feb554lfm0j30zk0qowi9.jpg" alt="" title="造化钟神秀"></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1feb55p487oj30zk0qodhk.jpg" alt="" title="玉皇顶风景"></p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcly1feb56dhiglj30zk0qo75t.jpg" alt="" title="玉皇顶风景"></p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcly1feb56rwok9j30zk0qo405.jpg" alt="" title="泰山风景"></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1feb5765exlj30zk0qodgm.jpg" alt="" title="泰山风景"></p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcly1feb57nzr75j30qo0zkmzv.jpg" alt="" title="山路"><br>五岳之首，泰山1500多米，确实有种霸气的感觉；泰山以其独特的文化气息在中国山脉届占有重要的地位。当经过疲惫的攀登，到达玉皇顶的那一刻还是感觉异常的兴奋，真的有众山小的感觉。</p>
<p>结束三天的旅行，虽然累，但是心情却是满足的；</p>
<p>其实人生就像一场旅行，在乎的不是目的地，在乎的是沿途的风景以及看风景的心情……</p>
<p>生活依然前行，旅行还在继续，下一个……</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tKfTcly1feb4zo2knfj31kw0w0aej.jpg&quot; alt=&quot;&quot; title=&quot;在路上&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="在路上" scheme="http://yoursite.com/categories/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
    
      <category term="在路上" scheme="http://yoursite.com/tags/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
      <category term="旅行" scheme="http://yoursite.com/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 阅读笔记(4)</title>
    <link href="http://yoursite.com/2017/03/08/Effective-C-4/"/>
    <id>http://yoursite.com/2017/03/08/Effective-C-4/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-04-14T05:07:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h1><hr>
<h2 id="18-条款18-让接口容易被正确使用，不易被误用"><a href="#18-条款18-让接口容易被正确使用，不易被误用" class="headerlink" title="18.条款18:让接口容易被正确使用，不易被误用"></a>18.条款18:让接口容易被正确使用，不易被误用</h2><a id="more"></a>
<p><strong>记住以下几点即可：</strong><br>1.好的接口很容易被正确使用，不容易被误用，我们需要在我们的所有接口中努力达成这些性质；<br>2.正确使用接口的办法包括接口的一致性，以及与内置类型的行为兼容；<br>3.防止误用的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。<br>4.tr1::shared_ptr支持定制型删除器。这可防止DLL问题，可被用来自动解除互斥锁等等；</p>
<hr>
<h2 id="19-条款19-设计class犹如设计type"><a href="#19-条款19-设计class犹如设计type" class="headerlink" title="19.条款19:设计class犹如设计type"></a>19.条款19:设计class犹如设计type</h2><p>这个条款需要记住，当定义一个新的class，也就定义了一个新的type。这就意味着我们重载函数和操作符，控制内存的分配和归还，定义对象的初始化和终结……都掌握在我们自己的手上。 m m<br>所以设计一个优秀的class是一项艰巨的任务。</p>
<hr>
<h2 id="20-条款20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#20-条款20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="20.条款20:宁以pass-by-reference-to-const替换pass-by-value"></a>20.条款20:宁以pass-by-reference-to-const替换pass-by-value</h2><p><strong>这个条款很重要</strong></p>
<p>缺省情况下C++以by value方式传递对象到函数，这样函数参数都是以实际参数的副本为初值，这些副本也是由对象的copy构造函数产出，这就使得pass-by-value成为昂贵的操作；</p>
<p><em>基于此，有两点好处需要详解</em><br>例一：</p>
<pre><code>class Person {
    public:
        Person();
        virtual ~Person();
        ...
    private:
        std::string name;
        std::string address;
};
class Student:public Person {
    public:
        Student();
        ~Student();
        ...
    private:
        std::string schoolName;
        std::string schoolAddress;
};
</code></pre><p>考虑这样的情况，调用函数validateStudent，这个函数需要一个Student的参数（by value），</p>
<pre><code>bool validateStudent （Student s）;         //函数接受一个by value的参数
Student plato；
bool platoIsOK = validateStudent(plato);    //调用函数
</code></pre><p>看一下吧。无疑，Student的copy构造函数会被调用，加上validataStudent返回s会被销毁，因此参数传递的成本是一次copy函数调用，一次Student析构函数调用；</p>
<p>这只是简单的一点，当我们深入去研究会发现，Student有两个string对象，所以每次构造Student同时也构造了两个string对象，同时Student对象继承字Person，Person中也有两个string对象，也需要构造两个string对象，最终结果是以by value传递参数会有一次Student copy构造函数，一次Person copy构造函数，4次string copy 构造函数，当销毁时伴随着6次析构的过程。所以一共是6次copy构造，6次析构；</p>
<p><strong>这样为避免如此多的消耗，我们需要用pass by reference-to-const</strong><br>这种传递方式效率要高很多：没有任何构造函数和析构函数被调用，因为没有任何新对象呗创建，<strong>但是这里的const是必要的</strong>，原来的by value 传递的是副本，无论怎么修改源对象时不变的，这里却不同了，所以加上const是必要的。</p>
<p>例二：<br>以by reference 方式传递参数可以避免slicing(对象切割)问题。就是说，当一个继承类对象以by value的方式传递并被视作一个基类对象，基类的copy 构造函数会被调用，从而造成本来是针对继承类的对象的性质全被切割掉了，仅仅留下了一个基类对象。</p>
<pre><code>class Windows {
    public:
        ...
        std::string name() const;
        virtual void display() const;        //实现方式1
};
class WindowsWithScrollBars:public Windows {
    public:
        ...
        virtual void display() const;        //实现方式2
};
</code></pre><p>现在我们需要打印窗口名称和显示窗口，<strong>这个是错误的</strong></p>
<pre><code>void printNameAndDisplay(Windows w){
    std::cout &lt;&lt;w.name();
    w.display();
}
</code></pre><p>当我们传递给函数一个WindowWithScrollBars对象</p>
<pre><code>WindowEithScrollBars wwsb;
printNameAndDisplay(wwsb);
</code></pre><p>参数w会百构造成一个Windows对象，因为这个是pass by value，这个WindowEithScrollBars对象的特有的信息会被切除；在printNameAndDisplay中无论传进来的对象原本是是什么类型，参数w都会被强制转化成Window对象，因此函数中调用display(),永远是调用Window::display();</p>
<p><strong>解决这个问题的方式就是 by reference-to-const 这样参数不会被切割，传进来什么类型就表现什么类型；</strong></p>
<p><strong>当我们审视C++编译器的底层，会发现references往往是以指针实现出来的，因此pass by reference通常意味着传递指针。但当对象时内置类型时，pass by value 却比 pass by reference效率更高，同时这个tip也适用于STL的迭代器和函数对象，习惯上这些都被设计成pass by value</strong></p>
<p><em>总结</em></p>
<p>1.尽量以pass-by-reference-to-const 替换pass-by-value前者通常比较高效，并可避免切割问题；<br>2.但针对内置类型，STL的迭代器和函数对象，pass-by-value更加高效；</p>
<hr>
<h2 id="21-条款21-必须返回对象时，别妄想返回其reference"><a href="#21-条款21-必须返回对象时，别妄想返回其reference" class="headerlink" title="21.条款21:必须返回对象时，别妄想返回其reference"></a>21.条款21:必须返回对象时，别妄想返回其reference</h2><p>任何时候看到一个reference声明式，你都应该立刻问自己，它的另一个名称是什么，因为它一定是某物的另一个名称。例如operator*为例，如果它返回一个reference，后者一定指向某个既有的对象，内含两个对象的乘积；</p>
<p>总结下来就是：</p>
<p><strong>绝对不要返回pointer或者reference指向一个local stack 对象，或返回reference指向一个heap-allocated对象，或者返回pointer或reference指向一个local static 对象而有可能同时需要多个这样的对象</strong></p>
<hr>
<h2 id="22-条款22-将成员变量声明为private"><a href="#22-条款22-将成员变量声明为private" class="headerlink" title="22.条款22:将成员变量声明为private"></a>22.条款22:将成员变量声明为private</h2><p><strong>总结起来：</strong></p>
<p>1.一定要将成员变量声明为private,这样能赋予客户访问数据的一致性，允许约束条件获得保障，并提供class作者以充分的实现弹性；</p>
<p>2.protected并不比public更具封装性；</p>
<hr>
<h2 id="23-条款23-宁以non-menber，non-friend替换menber函数"><a href="#23-条款23-宁以non-menber，non-friend替换menber函数" class="headerlink" title="23.条款23:宁以non-menber，non-friend替换menber函数"></a>23.条款23:宁以non-menber，non-friend替换menber函数</h2><p>要以non-member， non-freend函数替换member函数，这样做可以增加封装性，包裹弹性，和机能扩充性；</p>
<hr>
<h2 id="24-条款24-若所有参数皆需要类型转换，请为此采用non-menber函数"><a href="#24-条款24-若所有参数皆需要类型转换，请为此采用non-menber函数" class="headerlink" title="24.条款24:若所有参数皆需要类型转换，请为此采用non-menber函数"></a>24.条款24:若所有参数皆需要类型转换，请为此采用non-menber函数</h2><p><strong>如果需要为某个函数的所有参数进行类型转换，那么这个函数必须是个non-member函数，尤其是针对操作符重载</strong></p>
<hr>
<h2 id="25-条款25-考虑写出一个不抛出异常的swap函数"><a href="#25-条款25-考虑写出一个不抛出异常的swap函数" class="headerlink" title="25.条款25:考虑写出一个不抛出异常的swap函数"></a>25.条款25:考虑写出一个不抛出异常的swap函数</h2><p><strong>总结</strong><br>1.当std::swap 对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常；<br>2.如果你提供一个member swap ,也该提供一个non-member swap 用来调用前者。对于classes(而非templates),<br>也请特化std::swap;<br>3.调用swap时应对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”；<br>4.为“用户定义类型”进行谁提的templates全特化是好的，但不要在std内加入某些对std而言全新的东西</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;四-设计与声明&quot;&gt;&lt;a href=&quot;#四-设计与声明&quot; class=&quot;headerlink&quot; title=&quot;四.设计与声明&quot;&gt;&lt;/a&gt;四.设计与声明&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;18-条款18-让接口容易被正确使用，不易被误用&quot;&gt;&lt;a href=&quot;#18-条款18-让接口容易被正确使用，不易被误用&quot; class=&quot;headerlink&quot; title=&quot;18.条款18:让接口容易被正确使用，不易被误用&quot;&gt;&lt;/a&gt;18.条款18:让接口容易被正确使用，不易被误用&lt;/h2&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 阅读笔记(3)</title>
    <link href="http://yoursite.com/2017/03/06/Effective-C-3/"/>
    <id>http://yoursite.com/2017/03/06/Effective-C-3/</id>
    <published>2017-03-05T16:00:00.000Z</published>
    <updated>2017-04-07T02:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h2><hr>
<a id="more"></a>
<h3 id="13-条款13-以对象管理资源"><a href="#13-条款13-以对象管理资源" class="headerlink" title="13.条款13:以对象管理资源"></a>13.条款13:以对象管理资源</h3><p>在C++中，动态分配的内存是需要我们手动去释放掉的，否则就会造成内存泄漏。把资源放进对象内，我们便可以依赖C++的“析构函数”自动调用机制，确保资源被释放。</p>
<p>于是有两个关键的想法：<br><em>1.获得资源后立刻放进管理对象</em> <strong>资源取得时机就是初始化时机（RAII）</strong><br><em>2.管理对象运用析构函数确保资源被释放</em><br>标准库中提供的智能指针，auto_ptr,tr1::shared_ptrs就是在其析构函数内做delete，但不是delete[]，故在动态分配得到的array中使用这两者并不适用</p>
<p><strong>总结</strong><br>1.为防止资源泄露，应使用RAII对象，他们在构造函数中获得资源并在析构函数中释放资源；<br>2.两个常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向NULL。</p>
<hr>
<h3 id="14-条款14-在资源管理类中小心copy行为"><a href="#14-条款14-在资源管理类中小心copy行为" class="headerlink" title="14.条款14:在资源管理类中小心copy行为"></a>14.条款14:在资源管理类中小心copy行为</h3><p>这个情况是面对当一个RAII对象被复制时，会发生什么？<br>多数情况会有以下几种可能：<br><em>1.禁止复制；将copying操作声明为private。</em><br><em>2.对底层资源应用“引用计数法”，例如：tr1::shared_ptr</em><br><em>3.复制底部资源；复制底部资源管理对象时，进行的是深拷贝</em><br><em>4.转移底部资源的拥有权；</em></p>
<hr>
<h3 id="15-条款15-在资源管理类中提供对原始资源的访问"><a href="#15-条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15.条款15:在资源管理类中提供对原始资源的访问"></a>15.条款15:在资源管理类中提供对原始资源的访问</h3><p><strong>记住：</strong><br><em>1.API往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法，一般是显示提供get函数；</em><br>*2.对原始资源的访问可能经由显式转换或者隐式转换。一般而言显示转换更加安全，但是隐式转换对客户会比较方便；</p>
<hr>
<h3 id="16-条款16-成对使用new和delete时要采取相同的形式"><a href="#16-条款16-成对使用new和delete时要采取相同的形式" class="headerlink" title="16.条款16:成对使用new和delete时要采取相同的形式"></a>16.条款16:成对使用new和delete时要采取相同的形式</h3><p>当使用new(即通过new动态生成一个对象)，有两件事情发生：<br><em>1.内存被分配出来（通过名为operator new 的函数）</em><br><em>2.针对此内存会有一个（或更多）构造函数被调用。</em></p>
<p>当使用delete，也有两件事发生：<br><em>1.针对此内存会有一个（或者更多）析构函数被调用</em><br><em>2.之后内存被释放（通过名为operator delete 的函数）</em></p>
<p><strong>其中delete的最大问题在于：即将被删除的内存之内到底会有多少对象，多少对象决定了会有多少析构函数被调用，因为数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数</strong></p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1fedcrz3903j30hr058jra.jpg" alt=""></p>
<p>同样尽量不要对数组形式做typedef 动作</p>
<p><strong>总结</strong><br>如果在new表达式中使用[],必须在相应的delete表达式中也使用[]如果在new表达式中不使用[],一定不要在相应的delete表达式中使用[];</p>
<hr>
<h3 id="17-条款17-以独立语句将newed对象置入智能指针"><a href="#17-条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="17.条款17:以独立语句将newed对象置入智能指针"></a>17.条款17:以独立语句将newed对象置入智能指针</h3><p><strong>一句话：以独立语句将newed对象存储于智能指针内，即不要融合成一条语句，要分开写，否则编译器分不清语句的执行顺序，一旦异常被抛出，有可能导致难以觉察的资源泄露</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三-资源管理&quot;&gt;&lt;a href=&quot;#三-资源管理&quot; class=&quot;headerlink&quot; title=&quot;三.资源管理&quot;&gt;&lt;/a&gt;三.资源管理&lt;/h2&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 阅读笔记(2)</title>
    <link href="http://yoursite.com/2017/03/04/Effective-C-2/"/>
    <id>http://yoursite.com/2017/03/04/Effective-C-2/</id>
    <published>2017-03-03T16:00:00.000Z</published>
    <updated>2017-04-07T02:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-构造-析构-赋值运算"><a href="#二-构造-析构-赋值运算" class="headerlink" title="二.构造/析构/赋值运算"></a>二.构造/析构/赋值运算</h2><a id="more"></a>
<hr>
<h3 id="5-条款05-了解C-默默编写并调用哪些函数"><a href="#5-条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="5.条款05: 了解C++默默编写并调用哪些函数"></a>5.条款05: 了解C++默默编写并调用哪些函数</h3><p>这是个很重要的问题，我们声明的空类其实“并不空”，当C++处理过之后，如果在类中自己并没有声明任何函数和变量，编译器就会为它声明一个default构造函数，一个copy构造函数，一个析构函数，一个copy assignment操作符，一共四个，当然这些函数都是public且inline</p>
<p>例如我们声明了一个类：</p>
<pre><code>class Empty{};
</code></pre><p>其实编译器已经替我们做好了许多事，相当于生成下面的代码：</p>
<pre><code>class Empty{
    public:
        Empty(){...}
        Empty(const Empty&amp; this){...}
        ~Empty(){...}
        Empty&amp; operator=(const Empty &amp;rhs) {...}
};
</code></pre><p>因此这样，一个空类的大小并不是0,而是1，那是因为这个空类被编译器插进去的一个char,使得这个class的不同实体(object)在内存中配置是独一无二的，也就是说这个char是用来标识类的不同对象的；</p>
<hr>
<h3 id="6-条款06-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#6-条款06-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="6.条款06: 若不想使用编译器自动生成的函数，就该明确拒绝"></a>6.条款06: 若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>所有编译器产出的函数都是public，为了阻止这些函数被创建出来。我们需要自行声明它们，同时可将相应的成员函数声明为private并且不予实现。这样即可。</p>
<hr>
<h3 id="7-条款07-为多态基类声明virtual析构函数"><a href="#7-条款07-为多态基类声明virtual析构函数" class="headerlink" title="7.条款07: 为多态基类声明virtual析构函数"></a>7.条款07: 为多态基类声明virtual析构函数</h3><p>C++明确指出，当继承类对象经由一个基类指针被删除，而该基类带着一个non-virtual析构函数，则结果不明确（通常实际执行时发生的是对象的继承成分没被销毁）</p>
<p>virtual 函数的目的是允许derived class 的实现得以客制化；当基类有函数是virtual的，那么它在不同的继承类中会有不同的实现码，<strong>任何class只要带有virtual函数都几乎确定应该会有一个virtual析构函数</strong>；<br><em>如果一个class中不含有virtual函数，通常标识它并不试图作为基类，故class不企图被当作base class，尽量不要令析构函数为virtual</em></p>
<p>virtual函数的实现，对象需要带有一些信息，主要用来在运行期间决定哪个virtual函数被调用。这个信息由vptr(virtual table pointer)指针指出。vptr指向一个由函数指针构成的数组，成为vtbl(virtual table)；每个带有virtual函数的class都有一个相应的vtbl。当对象调用某一个virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl—–即编译器在寻找适当的函数指针；</p>
<p>纯虚函数有时可能会更加便利，纯虚函数导致抽象类—-不能被实体化的类。也就是说不可以为这种类创建对象。此时我们需要为抽象的类建立一个纯虚析构函数</p>
<pre><code>class AWOV{
    public;
        virtual ~AWOV() = 0；
};
</code></pre><p><strong>总结：</strong><br>给基类一个虚析构函数，只适用于带有多态性质的基类身上，这种基类的设计目的是为了用来通过基类接口处理继承类的对象。</p>
<hr>
<h3 id="8-条款08-别让异常逃离析构函数"><a href="#8-条款08-别让异常逃离析构函数" class="headerlink" title="8.条款08:别让异常逃离析构函数"></a>8.条款08:别让异常逃离析构函数</h3><p>1.析构函数绝对不要出现异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后处理他们或者结束程序；</p>
<p>2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（不是在析构函数中）执行该操作；</p>
<hr>
<h3 id="9-条款09-绝不在构造和析构函数中调用virtual函数"><a href="#9-条款09-绝不在构造和析构函数中调用virtual函数" class="headerlink" title="9.条款09:绝不在构造和析构函数中调用virtual函数"></a>9.条款09:绝不在构造和析构函数中调用virtual函数</h3><p>确定我们的构造函数和析构函数都没有（在对象被创建和销毁期间）调用virtual函数。否则会引起不明确的错误，在初始化期间；</p>
<hr>
<h3 id="10-条款10-令operator-返回一个reference-to-this"><a href="#10-条款10-令operator-返回一个reference-to-this" class="headerlink" title="10.条款10:令operator= 返回一个reference to *this"></a>10.条款10:令operator= 返回一个reference to *this</h3><p>令赋值操作符返回一个 reference to *this。</p>
<pre><code>class Widget{
    public:
        ...
        Widget&amp; operator= (const Widget &amp;rhs){
            ...
            return *this;
        }
        ...
};
</code></pre><hr>
<h3 id="11-条款11-在operator-中处理“自我赋值”"><a href="#11-条款11-在operator-中处理“自我赋值”" class="headerlink" title="11.条款11:在operator=中处理“自我赋值”"></a>11.条款11:在operator=中处理“自我赋值”</h3><p>1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的<strong>地址</strong>精心周到的语句顺序、以及copy-and-swap。</p>
<p>2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确；</p>
<p>其中还有一点自测行为的使用</p>
<pre><code>if(this == &amp;rhs)
    return *this;
</code></pre><hr>
<h3 id="12-条款12-复制对象时勿忘其每一个成分"><a href="#12-条款12-复制对象时勿忘其每一个成分" class="headerlink" title="12.条款12:复制对象时勿忘其每一个成分"></a>12.条款12:复制对象时勿忘其每一个成分</h3><p>这个针对复制构造函数和重载赋值操作符，当我们创建一个基类，并创建复制构造函数和重载了赋值操作符，同理它的继承类中创建了自己独有的数据成员，当在继承类中调用赋值构造函数时，我们如果只赋值了继承类中独有的数据成员，却没有对基类的成员进行任何操作，那么继承类中的继承基类的成员只能通过基类的构造函数来初始化。</p>
<p><em>所以，任何时候都需要为继承类写复制构造函数，必须很小心的复制基类的成分。那些成分是private的，我们无法直接访问它们，故应该让继承类的复制构造函数调用基类的相应的函数来初始化</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二-构造-析构-赋值运算&quot;&gt;&lt;a href=&quot;#二-构造-析构-赋值运算&quot; class=&quot;headerlink&quot; title=&quot;二.构造/析构/赋值运算&quot;&gt;&lt;/a&gt;二.构造/析构/赋值运算&lt;/h2&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 阅读笔记(1)</title>
    <link href="http://yoursite.com/2017/03/01/Effective-C-1/"/>
    <id>http://yoursite.com/2017/03/01/Effective-C-1/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2017-04-07T01:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><em><font size="3" face="微软雅黑">  最近在公司实习，做的是偏数据分析的事情，用的更多的是Python和Shell去开发和处理一些数据库和分布式系统中的数据，故之前相对熟悉的C++<a id="more"></a>的一些细节和原理有些已经记不清楚了，现在正赶上今年的校招故拾起来再看下，希望对自己寻找工作的过程和将来的职业生涯都有帮助；更重要的一点是接触的C++时间更长些，还是没有研究的很深入，所以再读一遍之前看过的书，复习一下，希望有更深的理解！<br></font></em></p>
<hr>
<h2 id="一-让自己习惯C"><a href="#一-让自己习惯C" class="headerlink" title="一.让自己习惯C++"></a>一.让自己习惯C++</h2><h3 id="1-条款01：视C-为一个语言联邦"><a href="#1-条款01：视C-为一个语言联邦" class="headerlink" title="1.条款01：视C++为一个语言联邦"></a>1.条款01：视C++为一个语言联邦</h3><p>一开始，C++只是C上加一些面向对象的特征。故C++最初的名称 C with Classes,但是C++并非一种单一语言，C++ 中各种规则都倾向于简单、直观、容易，因此我们理解C++也有了下面4个最主要的特征：<br><strong>(1) C </strong><br><em>说到底C++仍以C为基础，包括 区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型(build-in data types)、数组（arrays）、指针(pointers)都来自C。但是高效的编程守则指出了C的局限：没有模板（templates）,没有异常（exceptions）,没有重载(overloading)</em></p>
<p><strong>(2) Object-Oriented C++ </strong><br>这一部分是面向对象的精髓坐在：classes(构造函数和析构函数)、封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual 函数（动态绑定）……</p>
<p><strong>(3) Template C++ </strong><br>这是C++的泛型编程部分，威力非常强大，需要仔细学习</p>
<p><strong>(4) STL </strong><br>STL是template的程序库。它将容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象(fountion-objects)紧密的结合在一起</p>
<p><strong><em>还有一点，当我们从C转到C++后，pass-by-reference-to-const往往更加好用。C中的pass-by-value同样适用但是性能问题</em></strong></p>
<p><strong><em>因此高效编程要视情况而定</em></strong></p>
<p>—————————————————————————————————————————————</p>
<h3 id="2-条款02：尽量以const-enum-inline替换-define"><a href="#2-条款02：尽量以const-enum-inline替换-define" class="headerlink" title="2.条款02：尽量以const,enum,inline替换 #define"></a>2.条款02：尽量以const,enum,inline替换 #define</h3><p>这个问题曾经在我面试一个互联网公司时被问到了，当时答的也是不太清晰，尤其是面对原理时。</p>
<p><em>这个条款根据书中所说可以改成”宁可以编译器替换预处理器”更好</em>，我们在#define 后的记号或许就不就被编译器看到，或许在编译器开始处理源码之前就被预处理器移走了，于是记号就没有进入记号表(symbol table)中<br>。解决的方法就是用一个常量替换上述的宏（const）,作为语言常量，一定会被编译器看到。同时使用const比使用#define导致较小量的码。</p>
<p>针对const替换#define有两种特殊情况：</p>
<p><strong>(1) 定义常量指针</strong></p>
<p>由于常量定义式通常在头文件内，因此有必要将指针声明为const,这时使用string比char要优秀：</p>
<pre><code>const str::string str(&quot;hello world&quot;);
</code></pre><p><strong>(2) class专属常量</strong></p>
<p>为了将常量的作用于限制于class，这个常量必须定义在class内，<font size="3" face="黑体" color="#0099ff">而为了此常量没有其他副本，必须将它定义成static成员：</font></p>
<pre><code>class fruit{
    private:
        static const int num;
        int color[num];
        ……
};
</code></pre><p>同样可以在class内定义，或者class外定义：<br>    const int num = 5;<br>我们无法利用#define去创建一个class专属的变量，因为#define并不重视作用域。故不支持封装性</p>
<p><em>对于#define实现的宏，有时看起来更像函数，但不会有函数调用。这时就需要用inline取替换#define了</em></p>
<p><strong>总结：</strong><br><strong>对于单纯的常量，最好以const对象或enums替换#define</strong><br><strong>对于形似函数的宏（macros）,最好用inline函数替换#define</strong></p>
<p>—————————————————————————————————————————————</p>
<h3 id="3-条款03-尽可能使用const"><a href="#3-条款03-尽可能使用const" class="headerlink" title="3.条款03: 尽可能使用const"></a>3.条款03: 尽可能使用const</h3><p>const允许我们指定一个不被改变的对象，同时编译器会强制实施这项约束。const最优是用在面对函数声明时，const可以和函数返回值，各参数，函数自身产生关联。</p>
<p><strong>const成员函数</strong></p>
<p>将const实施于成员函数的目的是为了确认该成员函数可作用于const对象身上，这是很重要的：</p>
<p><1>这个使class接口比较容易被理解，即哪个函数可以，哪个不可以</1></p>
<p><2>它们使”操作const对象”成为了可能</2></p>
<p>—————————————————————————————————————————————</p>
<h3 id="4-条款04-确定对象被使用前已经先被初始化"><a href="#4-条款04-确定对象被使用前已经先被初始化" class="headerlink" title="4.条款04: 确定对象被使用前已经先被初始化"></a>4.条款04: 确定对象被使用前已经先被初始化</h3><p>针对将对象初始化，C和C++总是搞得很乱，其实在C++中已经通过default构造函数对对象进行了初始化，但是在non-C part of C++中并没有保障，所以我们的最佳处理就是永远在使用对象之前对它进行初始化，对于无任何成员的内置类型，必须手工完成初始化</p>
<p><strong>理解赋值(assignment)与初始化(initiazation)</strong></p>
<p>C++中，对象的成员变量的初始化动作发生在进入构造函数体之前，初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之前，故我们初始化的最佳方法是 <font size="3" face="黑体" color="#0099ff">成员初值列</font></p>
<pre><code>fruit::fruit(const str::string &amp;color, const str::string &amp;size){
    theColor = color;
    theSize = size;
}；    //这是赋值


fruit::fruit(const str::string &amp;color, const str::string &amp;size):
    theColor(color),
    theSize(size)
    {}       //这是初始化，通常这个效率更高
</code></pre><p><em>规定：总是在初值列中列出所有的成员变量，同时总是使用成员初始化列</em></p>
<p>C++有着固定的”成员初始化次序”: 基类早于派生类初始化，同时class的成员变量总是以其声明的次序被初始化，无论在初始化列表是什么顺序，所以我们在初始化时尽量与声明的保持一致</p>
<p>针对static对象，寿命在被构造开始到程序结束，即main()函数退出，C++对”定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确的次序，所以这就需要我们在编写程序时加强程序的设计。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;font size=3 face = &quot;微软雅黑&quot;&gt;  最近在公司实习，做的是偏数据分析的事情，用的更多的是Python和Shell去开发和处理一些数据库和分布式系统中的数据，故之前相对熟悉的C++
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
